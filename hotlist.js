var json = {"code":"<!DOCTYPE html>\n<!--\n                    Contest: Underground!\n                \n         I have completed 100% of Khan Academy's \n        'Intro to HTML/CSS' and have been programming \n                    for 40 months(ish).\n    \n          I would prefer to be placed in the\n                   [Intermediate]\n                       bracket\n                       \n    \n    I would have loved to make this so much better but I got a bad case of the flue and have mostly been stuck in bed :/ Anyways I am feeling alright for the moment so I thought I would take a second to post what I had but I won't enter Advanced because this just isn't quite good enough\n    \n    This is my very first project that uses WebGL, so not to shabby :) I would have added maybe monster eyes and a point of light that advances in front of you, but I can't right now because screens aren't good for you when you have a high temperature ðŸ¤’ XP\n    \n    Hope you guys like it, enjoy!\n    \n-->\n<html>\n    \n    <head>\n        <meta charset=\"utf-8\">\n        <title>3D cave</title>\n        <style>\n            #gl-canvas {\n                display: none;\n                overflow:hidden;\n            }\n            *{\n                overflow:hidden;\n                margin: 0px;\n                background: black;\n                width: 600px;\n            }\n        </style>\n    </head>\n    \n    <body>\n    \n    <!--Canvases -->\n    <canvas id = 'canvas' width = '600' height = '600'>\n    </canvas>\n    <canvas id = 'gl-canvas' width = '600' height = '600'>\n    </canvas>\n    \n    <!--Console-->\n    <div style=\"position: absolute; left: 10px; top: 10px; background-color: white;\" id=\"consol\">\n    </div>\n    \n    <!--Vertex-->\n    <script id = 'vertex-shader' type = 'glsl'>#version 300 es\n        in vec2 aPosition;\n        out vec2 pos;\n        \n        void main() {\n            \n            pos = aPosition;\n            gl_Position = vec4(aPosition, 0, 1);\n            \n        }\n        \n    </script>\n    \n    <!--Fragment-->\n    <script id = 'fragment-shader' type = 'glsl'>#version 300 es\n        \n        // --- setup ---\n        precision mediump float;\n        uniform vec2 u_resolution;\n        uniform float drawx;\n        uniform float drawy;\n        uniform float iTime;\n        out vec4 fragColor;\n        vec2 iResolution = vec2(600.0, 600.0);\n        \n        // The far plane\n        #define FAR 50.\n        \n        // 2x2 matrix rotation\n        mat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n        \n        // 1x1 and 3x1 hash functions.\n        float hash( float n ){ return fract(cos(n)*45758.5453); }\n        float hash( vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n        \n        \n        // Draw the object on the repeat tile\n        float drawObject(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n        \n        // Repeat cellular tile routine\n        float cellTile(in vec3 p){\n            \n            // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n            vec4 d; \n            d.x = drawObject(p - vec3(.81, .62, .53));\n            p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n            d.y = drawObject(p - vec3(.39, .2, .11));\n            p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n            d.z = drawObject(p - vec3(.62, .24, .06));\n            p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n            d.w = drawObject(p - vec3(.2, .82, .64));\n        \n            // Obtain the minimum, and you're done.\n            d.xy = min(d.xz, d.yw);\n                \n            return min(d.x, d.y)*2.66; // Scale between zero and one... roughly.\n        }\n        \n        // The path to follow\n        vec2 path(in float z){ return vec2(20.*sin(z * .04), 4.*cos(z * .09) + 3.*(sin(z*.025)  - 1.)); }\n        \n        // Perturb the walls of the passage structure\n        float surfFunc(in vec3 p){\n            \n            float c = cellTile(p/6.);\n            return mix(c, cos(c*6.283*2.)*.5 + .5, .125);\n        }\n        \n        // IQ's smooth minium function\n        float smin(float a, float b , float s){\n            \n            float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n            return mix(b, a, h) - h*(1.0-h)*s;\n        }\n        \n        // Smooth maximum, based on IQ's smooth minimum\n        float smax(float a, float b, float s){\n            \n            float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n            return mix(b, a, h) + h*(1.0-h)*s;\n        }\n        \n        // The cave\n        float map(vec3 p){\n            \n        \t// Surface function to perturb the walls\n            float sf = surfFunc(p);\n        \n            // A gyroid object to form the main passage base layer\n            float cav = dot(cos(p*3.14159265/10.0), sin(p.yzx*3.14159265/10.0)) + 2.0;\n            \n            // Mold everything around the path\n            p.xy -= path(p.z);\n            \n            // The oval tunnel. Basically, a circle stretched along Y\n            float tun = 1.5 - length(p.xy*vec2(0.5, 1.0));\n           \n            // Smoothly combining the tunnel with the passage base layer, then perturbing the walls\n            tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);\n            \n            // The ground\n            float gr = p.y + 8.0 - cav*.5 + (.5-sf)*.5;\n            \n            // The roof cutoff point\n            float rf = p.y - 20.0;\n            \n            // Smoothly combining the passage with the ground, and cap it off at roof height\n            return smax(smin(tun, gr, .1), rf, 1.);\n         \n         \n        }\n        \n        // Basic raymarcher\n        float trace(in vec3 ro, in vec3 rd){\n        \n            float t = 0., h;\n            \n            for(int i = 0; i < 128; i++){\n            \n                h = map(ro+rd*t);\n                if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break;\n                \n                t += h*0.8;\n\n            }\n        \n            return min(t, FAR);\n        }\n        \n        // Tetrahedral normal\n        vec3 normal(in vec3 p){  \n            vec2 e = vec2(-1., 1.)*0.001;   \n        \treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n        \t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n        }\n        \n        // Tri-Planar blending function\n        vec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n           \n            n = max(abs(n) - .2, .001);\n            n /= (n.x + n.y + n.z );\n        \tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n            return p*p;\n            \n        }\n        \n        // Texture bump mapping\n        vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n           \n            const vec2 e = vec2(0.001, 0);\n            \n            // Three gradient vectors rolled into a matrix\n            mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n            \n            vec3 g = vec3(0.367, 0.587, 0.299)*m;\n            g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n            \n            return normalize( n + g*bf );\n        \t\n        }\n        \n        // 3D value noise function.\n        float n3D(in vec3 p){\n            \n        \tconst vec3 s = vec3(7, 157, 113);\n        \tvec3 ip = floor(p); p -= ip; \n            vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n            p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n            h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n            h.xy = mix(h.xz, h.yw, p.y);\n            return mix(h.x, h.y, p.z); // Range: [0, 1].\n        }\n        \n        // Surface bump function\n        float bumpSurf3D( in vec3 p){\n        \n            float bmp = cellTile(p/3.)*.8 + cellTile(p)*.2;\n            float ns = n3D(p*6. - bmp*6.);\n            \n            return mix(bmp, 1. - abs(ns-.333)/.667, .05);\n        \n        }\n        \n        // Standard function-based bump mapping function.\n        vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n            \n            const vec2 e = vec2(0.001, 0);\n            float ref = bumpSurf3D(p);                 \n            vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                              bumpSurf3D(p - e.yxy),\n                              bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n                  \n            grad -= nor*dot(nor, grad);          \n                              \n            return normalize( nor + grad*bumpfactor );\n        \t\n        }\n        \n        //Soft shadows\n        float softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n        \n            float shade = 1.0;\n            \n            // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n            const int maxIterationsShad = 10; \n        \n            float dist = start;\n            float stepDist = end/float(maxIterationsShad);\n        \n            // Max shadow iterations - More iterations make nicer shadows, but slows things down.\n            for(int i = 0; i < maxIterationsShad; i++){\n                \n                float h = map(ro + rd*dist);\n                //shade = min(shade, k*h/dist);\n                shade = min(shade, smoothstep(0., 1., k*h/dist));\n                dist += clamp(h, .2, stepDist);\n                if (abs(h)<0.001 || dist > end) break;\n                \n            }\n            \n            return shade;\n            \n        }\n        \n        // Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n        float calculateAO( in vec3 p, in vec3 n){\n        \tfloat ao = 0.0, l;\n        \tconst float nbIte = 6.0;\n            const float maxDist = 3.;\n            for(float i = 1.; i < nbIte + .5; i++ ){\n            \n                l = (i*.66 + hash(i)*.34)/nbIte*maxDist;\n                \n                ao += (l - map( p + n*l ))/(1.+ l);\n                \n            }\n        \t\n            return clamp( 1.-ao/nbIte, 0., 1.);\n        }\n        \n        // Just a single color for the sky\n        vec3 getSky(){\n            return vec3(40, 10, 10)/255.0;\n        }\n        \n        // Code block to produce three layers of fine dust. Not sophisticated at all.\n        float trig3(in vec3 p){\n            p = cos(p*2. + (cos(p.yzx) + 1.)*1.57);// + iTime/10\n            return dot(p, vec3(0.1666)) + 0.5;\n        }\n        \n        // Low quality noise\n        float trigNoise3D(in vec3 p){\n        \n            // 3D transformation matrix.\n            const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n          \n        \tfloat res = 0.;\n        \n            float t = trig3(p*3.14159265);\n        \tp += (t);\n            p = m3RotTheta*p;\n            //p = (p+0.7071)*1.5;\n            res += t;\n            \n            t = trig3(p*3.14159265); \n        \tp += (t)*0.7071;\n            p = m3RotTheta*p;\n             //p = (p+0.7071)*1.5;\n            res += t*0.7071;\n        \n            t = trig3(p*3.14159265);\n        \tres += t*0.5;\n        \t \n        \treturn res/2.2071;\n            \n        }\n        \n        // Hash to return a scalar value from a 3D vector.\n        float hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n        \n        // Throw it all together\n        float getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n        \n            float mist = 0.;\n            ro += rd*t/3.; // Edge the ray a little forward to begin.\n            \n            for (int i = 0; i < 3; i++){\n                // Lighting. Technically, a lot of these points would be shadowed, but we're ignoring that.\n                float sDi = length(lp-ro)/FAR; \n        \t    float sAtt = 1./(1. + sDi*0.1 + sDi*sDi*0.01);\n        \t    // Noise layer.\n                mist += trigNoise3D(ro/2.)*sAtt;//trigNoise3D\n                \n                ro += rd*t/3.;\n                \n            }\n            \n            // Add a little noise, then clamp, and we're done.\n            return clamp(mist/1.5 + hash31(ro)*0.1-0.05, 0., 1.);\n        \n        }\n        \n        // Main loop\n        void main(){\n        \t\n        \t// Screen coordinates\n        \tvec2 u = (gl_FragCoord.xy - iResolution.xy*.5)/iResolution.y;\n        \t\n        \t// Camera Setup\n        \tvec3 ro = vec3(0, 0, iTime/10.0);\n        \tvec3 lookAt = ro + vec3((-drawx/600.0)-0.5, (drawy/600.0)+0.5, .5);\n        \tro.xy += path(ro.z);\n        \tlookAt.xy += path(lookAt.z);\n            \n            //Field of view    \n            float FOV = 3.14159265/2.5;\n            vec3 forward = normalize(lookAt - ro);\n            vec3 right = normalize(vec3(forward.z, 0, -forward.x ));\n            vec3 up = cross(forward, right);\n            \n            // Ray direction\n            vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n        \trd.xy = rot2(path(lookAt.z).x/64.)*rd.xy;\n        \t\n        \t//light position\n            vec3 lp = vec3(0, 0, (iTime+100.0)/10.0);\n            lp.xy += path(lp.z);\n            \n        \t// Raymarch\n            float t = trace(ro, rd);\n            \n            // Sky\n            vec3 sky = getSky();\n            \n            // The passage color\n            vec3 col = sky;\n            \n            // Surface point\n            vec3 sp = ro + t * rd;\n            \n            float pathHeight = sp.y - path(sp.z).y;\n\n            // Surface normal\n            vec3 sn = normal( sp );\n            \n            // Light direction vector\n            vec3 ld = lp-sp;\n            ld /= max(length(ld), 0.001);\n            \n            // We've hit something\n            if (t < FAR){\n                \n                // Texture scale factor.        \n                const float tSize = 1./4.;\n                \n                // Function based bump mapping.\n                sn = doBumpMap(sp, sn, .75/(1. + t/FAR*.25));\n                \n                // Bump mapping for gritty detailing\n                float bf = (pathHeight + 5. < 0.)?  .05: .025;\n                \n                // Shadows\n                float shd = softShadow(sp, ld, 0.05, FAR, 8.);\n                \n                // Ambient occlusion\n                float ao = calculateAO(sp, sn);\n                \n                // Diffuse\n                float dif = max( dot( ld, sn ), 0.0);\n                \n                // Specular\n                float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 10.);\n                \n                // Fresnel reflection\n                float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0);\n                \n                // Schlick approximation\n        \t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        \t\tfloat fre2 = mix(.2, 1., Schlick);\n               \n                // Global ambience\n                float amb = ao*.125 + fre*fre2*.2;\n                \n                // Mix two colors\n                vec3 c1 = vec3(50)/255.0;\n                vec3 c2 = vec3(150)/255.0;\n                col = clamp(\n                    //mix\n                    mix(\n                        c1,\n                        c2,\n                        -sn.y*.5 + pathHeight*.5 + 1.75\n                    ),\n                    //high\n                    c1,\n                    //low\n                    c2\n                );\n                \n                // Make the ground reflect just a little more\n                col += smoothstep(0., 1., -pathHeight - 5.5)*fre*.25;\n                \n                // A bit of sky reflection\n                col += getSky()*fre*fre2; \n                \n                // Combining all the terms from above\n                col = (col*(dif + amb)*0.4 + vec3(1)*fre2*spe)*shd*ao + amb*pow(col, vec3(2.));\n                \n            }\n           \n            // Combine the scene with the sky\n        \tfloat dust = getMist(ro, rd, lp, t)*(1.-clamp((pathHeight - 5.)*.125, 0., 1.));\n            sky = getSky()*mix(1.0, 0.5, dust);\n            \n            // Quadratic fade off\n            col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.0));\n            \n            // Linear fade off\n            //col = mix(col, sky, min(t*.75/FAR, 1.));\n            \n            // Standard way to do a square vignette\n            u = gl_FragCoord.xy/iResolution.xy;\n            col = min(col, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);\n            \n            //star\n            /*\n            float starDot = clamp(dot(normalize(rd), normalize(lp)), 0.0, 1.0);\n            vec3 star = 0.2 * vec3(1.0, 1.0, 1.0) * pow(starDot, 1000.0);\n            star += 0.4 * vec3(1.0, 1.0, 1.0) * pow(starDot, 1000.0);\n            star += 0.8 * vec3(1.0, 1.0, 1.0) * pow(starDot, 1000.0);\n            if(length(sp-ro)>length(lp-ro)){\n                col += star;\n            }*/\n\n            // Done\n            fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n            \n        }\n        \n    </script>\n    \n    <!--Main-->\n    <script type = 'module'>\n        \n        document.getElementById(\"consol\").style = \"display:none\";\n        const canvas = document.getElementById('canvas'),\n            ctx = canvas.getContext('2d');\n        \n        var mouseX = 300,\n            pmouseX = 0,\n            mouseY = 300,\n            pmouseY = 0,\n            clicked = false,\n            key = {};\n            \n        window.addEventListener(\"mouseover\", event => {\n            \n            pmouseX = mouseX;\n            pmouseY= mouseY\n            mouseX = event.pageX;\n            mouseY = event.pageY;\n        });\n        window.addEventListener(\"mousemove\", event => {\n            \n            pmouseX = mouseX;\n            pmouseY= mouseY\n            mouseX = Math.max(Math.min(event.pageX, 600), 0);\n            mouseY = Math.max(Math.min(event.pageY, 600), 0);\n         \n        });\n        \n        function createShader(gl, type, source) {\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n           \n            if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){\n                \n                document.getElementById(\"consol\").innerHTML = gl.getShaderInfoLog(shader);\n                document.getElementById(\"consol\").style = \"position: absolute; left: 10px; top: 10px; width:500px; height:350px; background-color: white;\";\n                \n                console.log(gl.getShaderInfoLog(shader));\n                \n            }\n           \n            return shader;\n        }\n        function createProgram(gl, vs, fs) {\n            const program = gl.createProgram();\n            gl.attachShader(program, vs);\n            gl.attachShader(program, fs);\n            gl.linkProgram(program);\n           \n            return program;\n        }\n        \n        function main() {\n            \n            const glCanvas = document.getElementById('gl-canvas'),\n                gl = glCanvas.getContext('webgl2');\n            \n            const vertexSource = document.getElementById('vertex-shader').textContent,\n                fragmentSource = document.getElementById('fragment-shader').textContent;\n           \n            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource),\n                fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n           \n            const program = createProgram(gl, vertexShader, fragmentShader);\n           \n            const aPosition = gl.getAttribLocation(program, 'aPosition')\n            const drawx = gl.getUniformLocation(program, \"drawx\");\n            const drawy = gl.getUniformLocation(program, \"drawy\");\n            const iTime = gl.getUniformLocation(program, \"iTime\");\n            const positions = new Float32Array([-1, -1, -1, 3, 3, -1]);\n            \n            var mousex = 0;\n            var mousey = 0;\n            var now;\n            \n            var frameCount = 0;\n            \n            //gets rid of old animation frames\n            for (let i = window.requestAnimationFrame(function() {}); i > 0; i--) {\n                window.cancelAnimationFrame(i);\n            }\n            \n            const posBuffer = gl.createBuffer();\n            \n            //idk how I'm gonna remember this XD\n            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n            gl.viewport(0, 0, 600, 600);\n            gl.clearColor(0, 0, 0, 1);\n            gl.useProgram(program);\n            gl.enableVertexAttribArray(aPosition);\n            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            ctx.font = \"30px monospace\";\n            ctx.fillStyle = 'rgb(225,25,25)';\n            \n            var pretime;\n            function render() {\n                \n                pretime = performance.now();\n                window.requestAnimationFrame(render);\n                \n                frameCount++;\n                \n                gl.uniform1f(drawx, -mouseX);\n                gl.uniform1f(drawy, -mouseY);\n                gl.uniform1f(iTime, frameCount);\n                gl.drawArrays(gl.TRIANGLES, 0, 3);\n               \n                ctx.drawImage(glCanvas, 0, 0);\n                \n            }\n           \n            render();\n            \n        }\n        main();\n\n    </script>\n    \n    <!--KA Restart-->\n    <script></script>\n    \n    </body>\n    \n</html>\n","title":"3D cave","votes":31,"type":"HTML","author":{"name":"Cataclysmic Code ðŸŒ©","id":"kaid_820167475461480890635740","avatar":"/images/avatars/svg/boggle-green.svg"},"dimensions":{"width":600,"height":600},"forks":[{"title":"Spin-off of \"3D cave\"","id":"5395072484294656","forks":0,"votes":1,"author":{"name":"Abdul Muqtadir","id":"kaid_318271971645763501843519"}}],"posts":{"tips":[{"replyCount":0,"votes":10,"date":"2024-10-20T16:38:59.266524Z","author":{"name":"Fifth","id":"kaid_1065213098995021368328526","avatar":"/images/avatars/svg/leaf-blue.svg"},"text":"You need to give credit to the Shadertoy author who actually made this program, especially considering this being a contest.\nshadertoy[.]com/view/MdtSRl","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":2,"date":"2024-10-20T06:53:57.905581Z","author":{"name":"CodeEngineer","id":"kaid_1042098132686409870152592","avatar":"/images/avatars/svg/leafers-sapling.svg"},"text":"Feel better :)\nBut first WebGL? Good job.\nIt is very pretty.\nvote++;\n\nI personally believe this could possibly win the Advanced bracket. You never know! :)","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":2,"date":"2024-10-20T17:43:30.049215Z","author":{"name":"kitty mascot","id":"kaid_1066778980955332043559618","avatar":"/images/avatars/svg/sneak-peak-green.svg"},"text":"this look so cool but also seems like something from my nightmares. :D","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-19T23:59:59.917599Z","author":{"name":"Oliver DiNova","id":"kaid_1051919807332490750365523","avatar":"/images/avatars/svg/blobby-green.svg"},"text":"that's awesome! hope you feel better ðŸ˜Ž","locked":false,"pinned":false,"replies":[]},{"replyCount":1,"votes":1,"date":"2024-10-19T22:59:15.723347Z","author":{"name":"1001programmer1001","id":"kaid_1078378520650574901650073","avatar":"/images/avatars/svg/cs-hopper-cool.svg"},"text":"Nice job. :D\np.s. Oh and sorry to hear you are not feeling well. I hope you are better soon.","locked":false,"pinned":false,"replies":[{"date":"2024-10-19T23:38:46.822011Z","author":{"name":"Cataclysmic Code ðŸŒ©","id":"kaid_820167475461480890635740","avatar":"/images/avatars/svg/boggle-green.svg"},"text":"Yeah, that's why I've been off KA for a while. Thanks I hope so too :)"}]},{"replyCount":0,"votes":1,"date":"2024-10-20T05:34:37.484416Z","author":{"name":"Avinasen [bio pls] ðŸ”›","id":"kaid_1179196812991584934767621","avatar":"/images/avatars/svg/leafers-sapling.svg"},"text":"That's oddly terrifying and mesmerizing at the same time o-O\nHope you get better soon!","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T05:16:55.522311Z","author":{"name":"WAHOO-Allwen ","id":"kaid_1280249000611495284384187","avatar":"/images/avatars/svg/leafers-sapling.svg"},"text":"My potato comp :C\nalso fell better soon.","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T19:15:59.225596Z","author":{"name":"Duke","id":"kaid_351465532815782433620675","avatar":"/images/avatars/svg/starky-ultimate.svg"},"text":"Sorry you feel sick!\n\nBut bro this is epic :O","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T00:51:52.688132Z","author":{"name":"Radar","id":"kaid_3902988618718040904060736","avatar":"/images/avatars/svg/leafers-seed.svg"},"text":"Wow nice!","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T15:33:47.461627Z","author":{"name":"ASBackup","id":"kaid_714780036830891967670231","avatar":"/images/avatars/svg/aqualine-tree.svg"},"text":"o-0 wow! this is amazing :D","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T12:26:12.570646Z","author":{"name":"Lemon Games","id":"kaid_847345921523275843149970","avatar":"/images/avatars/svg/boggle-green.svg"},"text":"For using WebGL for the first time, this looks great. I still have to learn it =P\nFeel better!","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":1,"date":"2024-10-20T16:31:14.497904Z","author":{"name":"Shifter -OFF-","id":"kaid_892112752920553577482062","avatar":"/images/avatars/svg/blobby-purple.svg"},"text":"Woah, This kinda creeps me out for some reason. Hope you feel better!","locked":false,"pinned":false,"replies":[]}],"questions":[]}}