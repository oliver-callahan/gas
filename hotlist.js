var json = {"code":"/**\n * Vote! Because that is how democracy works.\n * \n * If you are too young to vote, then encourage\n * your older family members to do so. Because\n * that is how democracy works.\n * \n * This is not an endorsement of any candidate. It\n * merely displays the two \"top-of-ticket\" candidates\n * in a RANDOM order, spinning in a RANDOM direction.\n * If you don't like the order or direction, Restart\n * the program.\n */\n\nfunction whatNewDoes() {\n    var obj = Object.create(this.prototype);\n    this.apply(obj, arguments);\n    return obj;\n}\nObject.constructor.prototype.new = whatNewDoes;\n\n(function(PVector) {\n    /*\n     * Khan Academy leaks objects.  Here is a PVector \"patch\" that\n     * can mitigate PVector leaks iff the programmer invokes\n     *      PVector.new()\n     * instead of \"new PVector()\".\n     */\n    \n    /* Reimplement the get method to call PVector.new(). */\n    function get() {\n        return PVector.new(this.x, this.y, this.z);\n    }\n    PVector.prototype.get = get;\n\n    /* Reimplement the cross method to call PVector.new(). */\n    function cross(v) {\n        var ax = this.x, ay = this.y, az = this.z;\n        return PVector.new(ay*v.z - az*v.y, az*v.x - ax*v.z, ax*v.y - ay*v.x);\n    }\n    PVector.prototype.cross = cross;\n    \n    /*\n     * Rewrite static function to invoke PVector.new().  Why the\n     * static method was not robotically generated is a mystery.\n     */\n    function sub(v1, v2) {\n        return PVector.new(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    }\n    PVector.sub = sub;\n    \n    /* Rewrite static function to invoke PVector.new(). */\n    function fromAngle(angle, v) {\n        v = v || PVector.new();\n        v.x = cos(angle);\n        v.y = sin(angle);\n        return v;\n    }\n    PVector.fromAngle = fromAngle;\n    \n    /* Rewrite static function to invoke PVector.new(). */\n    function random3D(v) {\n        var angle = Math.random() * TWO_PI;\n        var vz = Math.random() * 2 - 1;\n        var mult = Math.sqrt(1 - vz * vz);\n        var vx = mult * Math.cos(angle);\n        var vy = mult * Math.sin(angle);\n        if (! v) {\n            v = PVector.new(vx, vy, vz);\n        } else {\n            v.set(vx, vy, vz);\n        }\n        return v;\n    }\n    PVector.random3D = random3D;\n    \n    /* Rewrite static function to invoke PVector.new(). */\n    function lerp(v1, v2, amt) {\n        var retval = PVector.new(v1.x, v1.y, v1.z);\n        retval.lerp(v2, amt);\n        return retval;\n    }\n    PVector.lerp = lerp;\n\n    /* Let's also fix a real bug in Processing.js PVectors... */\n    function angleBetween(a, b) {\n        var cosine = a.dot(b) / (a.mag() * b.mag());\n        return acos(constrain(cosine, -1, 1));\n    }\n    PVector.angleBetween = angleBetween;\n\n})(PVector);  /* Patches PVector leaks... */\n\n/*\n * Constructor for 2D rendering matrix which inherits from\n * the Processing.js rendering matrices, PMatrix2D.  The\n * only documentation for PMatrix2D is the code found at \n * https://raw.github.com/processing-js/processing-js/v1.4.8/processing.js\n */\nvar RMatrix2D = (function() {\n    var isArray = Array.isArray;\n    var aTan2 = atan2;\n    var abs = Math.abs;\n    var sqrt = Math.sqrt;\n    var orthogEpsilon = 1/1024/16;\n    var epsilon = 1/1024/1024/1024;\n\n    /* Constructor function. Objects inherit everything from PMatrix2D */\n    function RMatrix2D() {\n        PMatrix2D.apply(this, arguments);\n        this.mops = Object.new();\n        this.eigenVector1 = PVector.new();\n        this.eigenVector2 = PVector.new();\n    }\n\n    /*\n     * Inherited PMatrix2D properties include:\n     *  elements: a six element array of numbers\n     *  set: function takes another PMatrix2D, an array, or six numbers\n     *  get: function replaced by RMatrix2D.prototype.get\n     *  reset: function sets this to the identity matrix\n     *  translate: function\n     *  determinant: function\n     *  invert: inverts the matrix in place; returns a success boolean\n     *  scale: function\n     *  apply: function this = this * argument(s); matrix multiplication\n     *  preApply: function this = argument(s) * this; matrix multiplication\n     *  mult: function(source, target) arguments are PVectors or arrays\n     *  rotate: function\n     *  print: function like printMatrix\n     * Others that are avoided are:\n     *  array: function returns a new array of this.elements\n     *  multX: function, computes only the X tansformation of a point\n     *  multY: function, computes only the Y tansformation of a point\n     *  skewX: function  (doesn't work)\n     *  skewY: function  (doesn't work)\n     *  shearX: function(angle)  (doesn't work and is replaced)\n     *  shearY: function(angle)  (doesn't work and is replaced)\n     *  transpose: function, does nothing!\n     *  rotateZ: invokes rotate\n     *  invRotateZ: function() undo rotateZ\n     *  invTranslate: function undo translate\n     *  invScale: function undo scale\n     */\n    RMatrix2D.prototype = Object.create(PMatrix2D.prototype);\n    RMatrix2D.prototype.resetMatrix = PMatrix2D.prototype.reset;  /* alias */\n    RMatrix2D.prototype.printMatrix = PMatrix2D.prototype.print;  /* alias */\n    RMatrix2D.prototype.transform = PMatrix2D.prototype.mult;  /* alias */\n\n    /* Return a clone of this. */\n    function get() {\n        return RMatrix2D.new(this);\n    }\n    RMatrix2D.prototype.get = get;\n    \n    /* Set the values of this RMatix2D.  Avoids KA leaks and loop detector. */\n    function setMatrix(src) {\n        var S;\n        if (src instanceof PMatrix2D) {\n            S = src.elements;\n        } else if (arguments.length === 6) {\n            S = arguments;\n        } else if (isArray(src)) {\n            S = src;\n        } else {\n            throw \"RMatrix2D.prototype.set: invalid arguments!\";\n        }\n        var E = this.elements = this.elements || [];\n        E.length = 0;\n        E.push(S[0], S[1], S[2], S[3], S[4], S[5]);\n    }\n    RMatrix2D.prototype.set = setMatrix;\n    \n    /* Provide the same functionality as pushMatrix() as a method. */\n    function push() {\n        this.stack = this.stack || [];  /* NB: Array.new() does not work */\n        this.stack.push(this.get());\n    }\n    RMatrix2D.prototype.push = RMatrix2D.prototype.pushMatrix = push;\n    \n    /* Provide the same functionality as popMatrix() as a method. */\n    function pop() {\n        var stack = this.stack;\n        if (stack && stack.length > 0) {\n            this.set(stack.pop());\n        }\n    }\n    RMatrix2D.prototype.pop = RMatrix2D.prototype.popMatrix = pop;\n    \n    /*\n     * Shear this RMatrix2D on the X axis by the stated angle.\n     * Interface and definition inspired by P5.js.\n     */\n    function shearX(angle) {\n        var t = tan(angle);\n        var rm = RMatrix2D.new(1, t, 0,\n                               0, 1, 0);\n        this.apply(rm);\n    }\n    RMatrix2D.prototype.shearX = shearX;\n    \n    /* Shear this RMatrix2D on the Y axis by the stated angle. */\n    function shearY(angle) {\n        var t = tan(angle);\n        var rm = RMatrix2D.new(1, 0, 0,\n                               t, 1, 0);\n        this.apply(rm);\n    }\n    RMatrix2D.prototype.shearY = shearY;\n    \n    /*\n     * Return the inverse of this matrix.  Caller provides\n     * a target results matrix or is provided a STATIC\n     * property of this matrix.\n     */\n    function inverse(results) {\n        var E = this.elements, e0 = E[0], e1 = E[1], e2 = E[2], e3 = E[3], e4 = E[4], e5 = E[5];\n        var d = this.determinant();\n        if (abs(d) < epsilon) {\n            throw \"No matrix inverse possible!\";\n        }\n        d = 1 / d;\n        results = results ||\n            (this.inverted = this.inverted || RMatrix2D.new());\n        results.elements.length = 0;\n        results.elements.push(\n            e4 *  d, e1 * -d, (e1 * e5 - e4 * e2) * d,\n            e3 * -d, e0 *  d, (e3 * e2 - e0 * e5) * d\n        );\n        return results;\n    }\n    RMatrix2D.prototype.inverse = inverse;\n    \n    /* \n     * Compute this 2×2 matrix's eigenvalues and UNIT eigenvectors. See\n     * http://www.math.harvard.edu/archive/21b_fall_04/exhibits/2dmatrices/index.html\n     * for formulas.\n     */\n    function eigen() {\n        var ev1 = this.eigenVector1;\n        var ev2 = this.eigenVector2;\n        var E = this.elements, e0 = E[0], e1 = E[1], e3 = E[3], e4 = E[4];\n        var halfTrace = (e0 + e4) / 2;\n        var discrim = halfTrace * halfTrace - this.determinant();\n        discrim = (discrim < epsilon) ? 0 : sqrt(discrim);\n        var lamda1 = this.lamda1 = halfTrace + discrim;\n        var lamda2 = this.lamda2 = halfTrace - discrim;\n        if (abs(e3) > epsilon) {\n            ev1.set(lamda1 - e4, e3, 0);\n            ev2.set(lamda2 - e4, e3, 0);\n        } else if (abs(e1) > epsilon) {\n            ev1.set(e1, lamda1 - e0, 0);\n            ev2.set(e1, lamda2 - e0, 0);\n        } else if (abs(e0 - lamda1) < epsilon) {\n            ev1.set(1, 0, 0);\n            ev2.set(0, 1, 0);\n            return;\n        } else {\n            ev2.set(1, 0, 0);\n            ev1.set(0, 1, 0);\n            return;\n        }\n        ev1.normalize();\n        ev2.normalize();\n    }\n    RMatrix2D.prototype.eigen = eigen;\n    \n    var myV = RMatrix2D.new();\n    var myP = RMatrix2D.new();\n    /*\n     * Find the Singular Value Decomposition of this. Parameters\n     * are all required RMatrix2D output targets. So this = U×S×VT.\n     * Returns true on success. See section 8.1 of\n     * https://datajobs.com/data-science-repo/SVD-Tutorial-[Kirk-Baker].pdf\n     */\n    function svd(U, S, VT) {\n        /* Degenerate matrices (collinear vectors) are a big fail. */\n        if (abs(this.determinant()) < epsilon) {\n            return false;\n        }\n        var E = this.elements, a = E[0], b = E[1], c = E[3], d = E[4];\n        \n        /* Special (simple) case for orthogonal vectors. */\n        if (abs(a*b + c*d) < orthogEpsilon) {\n            var magX = sqrt(a*a + c*c);\n            var magY = sqrt(b*b + d*d);\n            U.set(  a/magX, b/magY, 0,\n                    c/magX, d/magY, 0 );\n            S.set(  magX, 0, 0,\n                    0, magY, 0);\n            VT.resetMatrix();  /* VT = Identity matrix */\n            return true;\n        }\n        \n        /* U is derived from the eigenvector of EE' */\n        myP.set(a, c, 0, b, d, 0);  /* sets myP = E' */\n        myP.preApply(this);\n        myP.eigen();\n        var u1 = myP.eigenVector1, u2 = myP.eigenVector2;\n        U.set(u1.x, u2.x, 0, u1.y, u2.y, 0);\n        \n        /* S diag is 1/sqrt of the eigenvalues */\n        S.set(sqrt(myP.lamda1), 0, 0, 0, sqrt(myP.lamda2), 0);\n        \n        /* \n         * V = [v1, v2] where the column vectors\n         * v1 = (1/sqrt(lamda1))·E'·u1  and\n         * v2 = (1/sqrt(lamda2))·E'·u2.\n         */\n        var V = myV;\n        myP.set(a, c, 0, b, d, 0);  /* myP = E' */\n        myP.transform(u1, u1);\n        u1.div(S.elements[0]);\n        myP.transform(u2, u2);\n        u2.div(S.elements[4]);\n        V.set(u1.x, u2.x, 0, u1.y, u2.y, 0);\n        \n        /*\n         * Multiply U and V by minusOne if U does not appear to be a\n         * valid rotation matrix.  minusOne × minusOne === Identity, so\n         * U×S×V remains the same. minusOne = [ -1, 0, 0, 0, 1, 0 ].  This\n         * is the same as negating each X column vector of the two matrices.\n         */\n        U = U.elements;\n        V = V.elements;\n        if (U[0] * U[4] <= 0) {\n            U[0] *= -1;\n            U[3] *= -1;\n            V[0] *= -1;\n            V[3] *= -1;\n        }\n        \n        VT.set(V[0], V[3], 0, V[1], V[4], 0);  /* VT = V' */\n        return true;\n    }\n    RMatrix2D.prototype.svd = svd;\n    \n    var myU = RMatrix2D.new();\n    var myS = RMatrix2D.new();\n    var myVT = RMatrix2D.new();\n    var rotReflect =  RMatrix2D.new();\n    var tuY = PVector.new();\n    /*\n     * This method provides the arguments to translate,\n     * rotate, and scale that can reconstruct a rendering\n     * matrix. Results parameter is returned. If no results\n     * parameter is given then a STATIC object is returned.\n     * Will return null on failure.  See applyMopsToPJS()\n     * for HOW to apply the transformations.\n     */\n    function reconstitute(results) {\n        var matrix = this;\n        if (! matrix.determinant) {\n            return null; // more KA silliness\n        }\n        var atan2 = aTan2;\n        var mops = results || matrix.mops;\n        var E = matrix.elements;\n        mops.tx = E[2];\n        mops.ty = E[5];\n        if (matrix.determinant() < 0) {\n            /*  \n             * A negative determinant means that the Y axis\n             * is a negative angle from X axis in a universe \n             * where the Y axis must be a positive angle from X axis.\n             * So, find the SVD of a similar \"positive\" matrix whose\n             * X column vector is collinear with the X axis, and\n             * whose Y column vector is reflected by the X axis.\n             */\n            var a = E[0], b = E[1], c = E[3], d = E[4];\n            tuY.set(b, d, 0);\n            mops.rot0 = atan2(c, a);  /* rotation FROM X axis */\n            tuY.rotate(-mops.rot0);  /* normalize tuX & tuV back TO X axis. */\n            rotReflect.set(sqrt(a*a + c*c), tuY.x, 0, 0, -tuY.y, 0);\n            matrix = rotReflect;\n            mops.initSy = -1;  /* reconcile reflection, -tuY.y */\n        } else {\n            mops.rot0 = 0;  /* no rotation */\n            mops.initSy = 1;  /* no reflection */\n        }\n        \n        /* Now, factor matrix into three matrices... */\n        if (! matrix.svd(myU, myS, myVT)) {\n            return null;\n        }\n        \n        /*\n         * Since matrix = U×S×VT, compute arguments to rotate and\n         * scale that can reconstruct matrix. Do the first rotate...\n         */\n        mops.rot1 = atan2(myU.elements[3], myU.elements[0]);\n        /* Then do a scale. */\n        mops.sx = myS.elements[0];\n        mops.sy = myS.elements[4];\n        /* Finally do another rotate. */\n        mops.rot2 = atan2(myVT.elements[3], myVT.elements[0]);\n        return mops;\n    }\n    RMatrix2D.prototype.reconstitute = reconstitute;\n    \n    /*\n     * Static function applies the results of the reconstitute()\n     * method to THE Processing.js rendering matrix. The only\n     * way to do that is via a series of tranformation calls.\n     * Returns true if mops.\n     */\n    function applyMopsToPJS(mops) {\n        if (mops) {\n            void((mops.tx || mops.ty) && translate(mops.tx, mops.ty));\n            void(mops.rot0 && rotate(mops.rot0));\n            void((mops.initSy !== 1) && scale(1, mops.initSy));\n            void(mops.rot1 && rotate(mops.rot1));\n            void((mops.sx !== 1 || mops.sy !== 1) && scale(mops.sx, mops.sy));\n            void(mops.rot2 && rotate(mops.rot2));\n            return true;\n        }\n    }\n    RMatrix2D.applyMopsToPJS = applyMopsToPJS;\n    \n    /*\n     * Apply this RMatrix2D to THE Processing.js rendering matrix.\n     * Returns true iff successful.\n     */\n    function applyMopsToPJS() {\n        return RMatrix2D.applyMopsToPJS(this.reconstitute());\n    }\n    RMatrix2D.prototype.applyMopsToPJS = applyMopsToPJS;\n    \n    /*\n     * (The Holy Grail.)\n     * Static function applies the RMatrix2D rm to THE \n     * Processing.js rendering matrix. If you want to SET\n     * the Processing.js matrix, then invoke resetMatrix()\n     * prior to invoking this function.  Returns true iff\n     * successful.\n     */\n    function applyMatrix(/* rm */) {\n        var rm = arguments[0];  /* KA silliness */\n        return rm.applyMopsToPJS();\n    }\n    RMatrix2D.applyMatrix = applyMatrix;\n    \n    /*\n     * Static function that converts the string\n     * produced by Processing.js printMatrix to a\n     * RMatrix2D object.  KA printMatrix() outputs\n     * six numbers on two lines that look like \n     *      a b c\n     *      d e f\n     * You should pass ONE string that looks like\n     *      a b c d e f\n     * where the numbers are separated by blanks.\n     * Optional parameter results is where the result\n     * are placed and returned.  It must be a RMatrix2.\n     * If none is provided then a new one is created.\n     */\n    function string2RMatrix(s, results) {\n        try {  /* more KA silliness */\n            results = results || RMatrix2D.new();\n            var token = s.split(\" \");\n            var num = results.elements;\n            for (var n = 0, i = 0; (n < 6) && (i < token.length); i++) {\n                var f = parseFloat(token[i]);\n                if (f > f - 1) {\n                    /* f is really a (useful) number */\n                    num[n++] = f;\n                }\n            }\n            if (n !== 6) {\n                println(\"Expected six, but got \" + n + \" numbers!\");\n            }\n            return results;\n        } catch(err) {}\n    }\n    RMatrix2D.string2RMatrix = string2RMatrix;\n    \n    /* Names of extremely interesting Processing.js functions. */\n    RMatrix2D.transforms = [ \"translate\", \"scale\", \"rotate\",\n        \"pushMatrix\", \"popMatrix\", \"resetMatrix\" ];\n        \n    /*\n     * This static function returns a RMatrix2D that \n     * reflects the transformation operations performed\n     * on the Processiong.js transformation functions.\n     * Sane people will most likely invoke this after a\n     * resetMatrix().\n     * The Interpose parameter is the Interpose library that\n     * knows how to capture calls to Processing.js.  Get that\n     * library at \n     * https://www.khanacademy.org/cs/i/5992045511049216\n     */\n    function mirrorPJS(Interpose) {\n        var mirror = RMatrix2D.new();\n\n        /*\n         * This interpose-function invokes the equivalent\n         * method in the RMatrix2D object \"mirror\" that \n         * reflects the Processing.js rendering matrix.\n         */\n        function mirrorMatrixOp() {\n            var mirroredFunction = mirror[this.name];\n            if (mirroredFunction && mirroredFunction.apply) {\n                /*\n                 * This should ALWAYS be the case, but life with the\n                 * KA live-editor and resetMatrix is really tough.\n                 */\n                mirroredFunction.apply(mirror, arguments);\n            }\n        }\n        \n        /* Interpose plumbing... */\n        RMatrix2D.transforms.forEach(\n            function(val) { Interpose.push(val, mirrorMatrixOp); });\n        \n        /* Undo method.  The method itself disappears... */\n        function breakMirror() {\n            RMatrix2D.transforms.forEach(\n                function(val) { Interpose.pop(val); });\n            delete mirror.breakMirror;\n        }\n        mirror.breakMirror = breakMirror;\n        \n        return mirror;\n    }\n    RMatrix2D.mirrorPJS = mirrorPJS;\n    \n    return RMatrix2D;  // last edited 2023.03.11\n})();  /* RMatrix2D is a constructor copied from www.khanacademy.org/cs/mr/3793059675 */\n\n/*\n * Draw a star with \"spikes\" points (default 5) with the\n * radius of the encompassing circle set to \"extRadius\"\n * (default 100), and whose center is at coordinates \"x\" and\n * \"y\" (both default to 0).\n *\n * The first spike of the star is drawn at angle \"first\"\n * (defaulted to the high vertical angle, aka -90°).\n *\n * The caller has already chosen the fill and stroke parameters.\n */\nvar drawStar = function(x, y, extRadius, spikes, first) {\n    x = (x === undefined) ? 0 : x;\n    y = (y === undefined) ? 0 : y;\n    spikes = (spikes === undefined) ? 5 : spikes;\n    extRadius = (extRadius === undefined) ? 100 : extRadius;\n    var tau = (cos(PI) < 0) ? TWO_PI : 360;\n    /* Computed with some Geometry and the Law of Sines: */\n    var interior = extRadius * sin(1/20 * tau) / sin(7/20 * tau);\n \n    pushMatrix();\n    translate(x, y);\n    rotate((first === undefined) ? -tau/4 : first);\n    beginShape();\n    /* Draw the star in two times the spike count easy steps */\n    for (var theta = 0; theta < tau; theta += tau / (2 * spikes)) {\n        var radius = (radius === extRadius) ? interior : extRadius;\n        vertex(radius * cos(theta), radius * sin(theta));\n    }\n    endShape(CLOSE);\n    popMatrix();\n};\n\nvar rm = new RMatrix2D();\nvar tX = width/2;\nvar tY = height/2;\nvar rot = (random() < 0.5) ? 2 : -2;\nvar republican = 0xFFde0100, stripe1 = republican;\nvar democrat = 0xFF0015bc, stripe2 = democrat;\nvar backgroundColour = color(5, 5, 32);\nvar w = 50;\nvar h = 300;\nvar faceImg = [];\nvar nodes = [];\nvar faces = [];\n\nvar init = function() {\n\n    function getFace(blurb) {\n        blurb = blurb.split(\"\").join(\"\\n\");\n        textAlign(CENTER, TOP);\n        textFont(createFont(\"monospace\"));\n        textSize(floor(w/2));\n        text(blurb, w/2, w);\n        text(blurb, w/2, w);\n        var img = get(0, 0, w, h);\n        return img;\n    }\n    \n    imageMode(CENTER);\n    background(republican);\n    fill(255);\n    var tface = getFace(\"Trump\");\n    background(democrat);\n    var hface = getFace(\"Harris\");\n    background(255);\n    if (random() < 0.5) {\n        stripe2 = republican;\n        stripe1 = democrat;\n    }\n    noStroke();\n    fill(stripe1);\n    rect(0, 0, 7, height);\n    fill(stripe2);\n    rect(w-8, 0, 7, height);\n    fill(0, 0, 0);\n    var vFace = getFace(\" VOTE\");\n    \n    faceImg.push(vFace);\n    if (vFace.get(0, 0) === tface.get(0, 0)) {\n        faceImg.push(tface, hface);\n    } else {\n        faceImg.push(hface, tface);\n    }\n    \n    var topY = -h/2, bottomY = h/2;\n    var r = w/sqrt(3);\n    for (var theta = -90, i = 0; i < 3; i++, theta -= 120) {\n        var x = r * cos(theta);\n        var z = r * sin(theta);\n        var node = {x: x, y: topY, z: z};\n        nodes.push(node);\n        node = {x: x, y: bottomY, z: z};\n        nodes.push(node);\n    }\n    for (var prev = 2, i = 0; i < 3; prev = i++) {\n        var face = [\n            nodes[2*prev],\n            nodes[2*i],\n            nodes[2*i + 1],\n            nodes[2*prev + 1]\n        ];\n        face.img = faceImg[i];\n        faces.push(face);\n    }\n    background(255); // reset canvas\n};\n\n/* Draw one face, f and optionally its edges. */\nvar drawFace = function(f, drawEdges) {\n    var n = f, ox = n[0].x, oy = n[0].y, last = n.length - 1;\n    rm.set( (n[1].x - ox) / w, (n[last].x - ox) / w, ox,\n            (n[1].y - oy) / h, (n[last].y - oy) / h, oy);\n    pushMatrix();\n    if (RMatrix2D.applyMatrix(rm)) {\n        imageMode(CORNER);\n        image(f.img, 0, 0);\n    }\n    popMatrix();\n    for (var j = n.length-1, i = 0; drawEdges && i < n.length; j = i, i++) {\n        stroke(200);\n        line(n[j].x, n[j].y, n[i].x, n[i].y);\n    }\n};\n\n/*\n * Rotate shape around a major axis, affecting\n * the specified X and Y properties.\n */\nvar rotate3D = function(theta, xProp, yProp) {\n    var sinTheta = sin(theta);\n    var cosTheta = cos(theta);\n\n    for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n        var x = node[xProp];\n        var y = node[yProp];\n        node[xProp] = x * cosTheta - y * sinTheta;\n        node[yProp] = y * cosTheta + x * sinTheta;\n    }\n};\n\n// Rotate shape around the z-axis.\nvar rotateZ3D = function(theta) {\n    return rotate3D(theta, \"x\", \"y\");\n};\n\n// Rotate shape around the y-axis & find minimum z value.\nvar rotateY3D = function(theta) {\n    return rotate3D(theta, \"z\", \"x\");\n};\n\n// Rotate shape around the x-axis & find minimum z value.\nvar rotateX3D = function(theta) {\n    return rotate3D(theta, \"y\", \"z\");\n};\n\n/* Return true iff the cube face is visible. */\nvar cam = new PVector(0, 0, 400);\nvar faceIsVisible = function(face) {\n    var nodes = face;\n    var ox = nodes[0].x, oy = nodes[0].y, oz = nodes[0].z;\n    var v1 = PVector.new(nodes[1].x - ox, nodes[1].y - oy, nodes[1].z - oz);\n    var v2 = PVector.new(nodes[2].x - ox, nodes[2].y - oy, nodes[2].z - oz);\n    var norm = v1.cross(v2);\n    return cam.dot(norm) > 0;\n};\n\n/* Called to draw the canvas. */\nvar render = function() {\n    pushMatrix();\n    translate(tX, tY);\n    background(backgroundColour);\n    fill(240);\n    drawStar(0, 0.05*width, 0.52*width, 5);\n    stroke(0, 0, 0);\n    line(0, -height/3, 0, height/2-20);\n    \n    // Draw the visible faces\n    for (var n = 0; n < faces.length; n++) {\n        var face = faces[n];\n        if (faceIsVisible(face)) {\n            drawFace(face, true);\n        }\n    }\n    \n    stroke(0);\n    popMatrix();\n};\n\n/* Called by Processing.js numerous times a second. */\ndraw = function() {\n    if (faceImg.length < 3) {\n        init();\n        rotateY3D(-120);\n    }\n    rotateY3D(rot);\n    render();\n};\n\nmouseClicked = function() {\n    println(\"www.IWillVote.com\");\n    loop();\n};\n\n/*\n * Called by Processing.js when the ...\n * Position for a thumbnail.\n */\nkeyTyped = function() {\n    noLoop();\n    redraw();\n    println(\"www.IWillVote.com\");\n};\n\n// I am honored any time anybody uses my code for any purpose.\n// Copy freely! All my programs are at\n// https://www.khanacademy.org/profile/BobLyon/programs\n","title":"VOTE in 2024","votes":16,"created":"10 hours ago","updated":"10 hours ago","type":"PJS","author":{"name":"Bob Lyon","id":"kaid_1116520053705160540512971","avatar":"/images/avatars/svg/old-spice-man.svg"},"dimensions":{"width":400,"height":400},"forks":[],"posts":{"tips":[{"replyCount":6,"votes":4,"date":"2024-10-28T13:30:08.237079Z","author":{"name":"Ezra","id":"kaid_1112279572017452692208390","avatar":"/images/avatars/svg/leaf-red.svg"},"text":"Cool Program Mr Lyon.\nBut may I ask to add the other candidates? Thank you :)","locked":false,"pinned":false,"replies":[{"date":"2024-10-28T13:31:07.307691Z","author":{"name":"The Coding Speedster [SEMI-INACTIVE]","id":"kaid_14029202341678142587410","avatar":"/images/avatars/svg/piceratops-ultimate.svg"},"text":"What other candidates?"},{"date":"2024-10-28T13:34:25.171426Z","author":{"name":"Mathlete11","id":"kaid_4902531429433401500771997","avatar":"/images/avatars/svg/starky-sapling.svg"},"text":"the other 3rd parties, like the green party"},{"date":"2024-10-28T13:40:42.711271Z","author":{"name":"The Coding Speedster [SEMI-INACTIVE]","id":"kaid_14029202341678142587410","avatar":"/images/avatars/svg/piceratops-ultimate.svg"},"text":"He's most likely not going to add them or any candidates. If you check the top of his code, he says that, \"This is not an endorsement of any candidate. It merely displays the *two \"top-of-ticket\" candidates* in a RANDOM order, spinning in a RANDOM direction.\""},{"date":"2024-10-28T13:45:07.132173Z","author":{"name":"Mathlete11","id":"kaid_4902531429433401500771997","avatar":"/images/avatars/svg/starky-sapling.svg"},"text":"yea, prob not, but its fine"},{"date":"2024-10-28T13:49:09.340868Z","author":{"name":"Ezra","id":"kaid_1112279572017452692208390","avatar":"/images/avatars/svg/leaf-red.svg"},"text":"I read that message but there is no reason why he could not add the other candidates..."},{"date":"2024-10-28T13:51:54.058838Z","author":{"name":"Mathlete11","id":"kaid_4902531429433401500771997","avatar":"/images/avatars/svg/starky-sapling.svg"},"text":"true :("}]},{"replyCount":0,"votes":2,"date":"2024-10-28T14:08:13.701422Z","author":{"name":"Liam K.","id":"kaid_160653079463992085090428","avatar":"/images/avatars/svg/duskpin-ultimate.svg"},"text":"Cool program with a great message. My ballot is already signed and sealed! If you're out there and of the legal voting age, I encourage you to vote as well.\n\nYou can always head to this website to check your eligibility if you are unaware of your current status.\nhttps //www vote411 org/check-registration\n\nLet's make the most of the 2024 election cycle!","locked":false,"pinned":false,"replies":[]},{"replyCount":0,"votes":2,"date":"2024-10-28T14:24:39.351376Z","author":{"name":"Coder2098","id":"kaid_673573024191290348573492","avatar":"/images/avatars/svg/aqualine-ultimate.svg"},"text":"This is a great program! however i would reccomend revising ur comments as we aren't a democracy we're a constitional republic but other than that this is great!","locked":false,"pinned":false,"replies":[]},{"replyCount":1,"votes":1,"date":"2024-10-28T10:35:58.744053Z","author":{"name":"LJ","id":"kaid_1144628223469068678737336","avatar":"/images/avatars/svg/leafers-sapling.svg"},"text":"Is it just me, or is the axis of rotation not at the center?","locked":false,"pinned":false,"replies":[{"date":"2024-10-28T14:03:23.302929Z","author":{"name":"Th3 Roug3 L3g3nd","id":"kaid_2809101008758048501324524","avatar":"/images/avatars/svg/old-spice-man-blue.svg"},"text":"it's true"}]},{"replyCount":0,"votes":0,"date":"2024-10-28T14:04:01.98378Z","author":{"name":"Th3 Roug3 L3g3nd","id":"kaid_2809101008758048501324524","avatar":"/images/avatars/svg/old-spice-man-blue.svg"},"text":"could we Collab?","locked":false,"pinned":false,"replies":[]}],"questions":[]}}