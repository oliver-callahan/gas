var json = {
    "code": "<!DOCTYPE html>\n<!--\n\nPlease include this (or something similar) at the top of your program if you use my tutorial:\n\nCredit to Liam K's Platformer Tutorial:\nhttps://www.khanacademy.org/cs/i/4978980719378432\n\n\nWhile the last few weeks has been a whirlwind of activity, I did get enough time this\nweekend to do some coding here on KA.\n\nIf you find any bugs with my code (pesky semicolons), please don't hesitate to tell me \nabout them so I can fix them ASAP. Additionally, if you feel like any parts of this \ntutorial are unclear, please tell me so I can help clarify.\n\nI would be incredibly appeciative if you would pop on over to my subpage and\ndrop a period in my subscription thread.\n\nhttps://www.khanacademy.org/cs/i/6652809926492160\n\nSorry for the clickbaity thumbnail\n\n-->\n<html>\n\n<head>\n\t<meta charset=\"utf-8\">\n\t<title>Platformer Tutorial 2.0</title>\n\t<link rel=\"stylesheet\" id=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/dracula.min.css\" />\n\t<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\">\n\t<link href=\"https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap\" rel=\"stylesheet\">\n\t<script src=\"https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js\"></script>\n\t<script src=\"https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.3/dist/html2canvas.min.js\">\n\t</script>\n\t<style>\n\t\tbody,\n\t\thtml,\n\t\thead {\n\t\t\tmargin: 0;\n\t\t\tbackground-color: rgb(50, 50, 50);\n\t\t\toverflow-x: hidden;\n\t\t}\n\n\t\th1,\n\t\th2,\n\t\th3 {\n\t\t\ttext-align: center;\n\t\t\tfont-family: 'Titillium Web';\n\t\t\tmargin: 0;\n\t\t\tcolor: rgba(255, 255, 255);\n\t\t}\n\n\t\th1 {\n\t\t\tfont-size: 50px;\n\t\t}\n\n\t\th2 {\n\t\t\tfont-size: 35px;\n\t\t}\n\n\t\th3 {\n\t\t\tfont-size: 30px;\n\t\t\tmargin: 20px 50px;\n\t\t\tborder-radius: 50px;\n\t\t}\n\n\t\th4,\n\t\th5 {\n\t\t\tcolor: white;\n\t\t\tfont-family: 'Titillium Web';\n\t\t\tmargin: 20px 50px;\n\t\t\tfont-size: 20px;\n\t\t}\n\n\t\tfooter {\n\t\t\tcolor: white;\n\t\t\tfont-family: 'Titillium Web';\n\t\t\tmargin: 0px;\n\t\t\ttext-align: center;\n\t\t\tpadding: 50px;\n\t\t\tfont-size: 20px;\n\t\t}\n\n\t\th5 {\n\t\t\tfont-size: 17px;\n\t\t}\n\n\t\tp,\n\t\tul,\n\t\tol {\n\t\t\tmargin-left: 50px;\n\t\t\tmargin-right: 50px;\n\t\t\tcolor: white;\n\t\t\tfont-family: 'Titillium Web';\n\t\t}\n\n\t\tli {\n\t\t\tmargin: 0px 0px;\n\t\t}\n\n\t\ta:hover,\n\t\ta:link,\n\t\ta:visited {\n\t\t\tcolor: white;\n\t\t}\n\n\t\t.parallax {\n\t\t\tbackground-image: url(\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Abstract_blue_background7.jpg/800px-Abstract_blue_background7.jpg\");\n\n\t\t\tbackground-position: center;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-size: cover;\n\t\t\tbackground-attachment: fixed;\n\t\t\tposition: relative;\n\t\t}\n\n\t\t.hljs {\n\t\t\tmargin: 20px 50px;\n\t\t\tbackground-color: rgb(40, 40, 40);\n\t\t\tborder-radius: 10px;\n\t\t}\n\n\t\t.question {\n\t\t\tmargin-bottom: 20px;\n\t\t}\n\n\t\t.question h5 {\n\t\t\tdisplay: flex;\n\t\t\tbackground-image: url(\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Abstract_blue_background7.jpg/800px-Abstract_blue_background7.jpg\");\n\n\t\t\tbackground-position: center;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-size: cover;\n\t\t\tbackground-attachment: fixed;\n\t\t\tposition: relative;\n\n\t\t\tmargin: 0 50px;\n\t\t\tpadding: 10px;\n\t\t\tborder-radius: 10px;\n\t\t\tjustify-content: center;\n\n\t\t\ttransition: text-shadow 0.2s;\n\t\t}\n\n\t\t.question h5:hover {\n\t\t\ttext-shadow: 0 0 10px rgba(255, 255, 255);\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t.question p,\n\t\t.question pre {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.question p.open {\n\t\t\tbackground-color: rgb(40, 40, 40);\n\t\t\tmargin: 0px 50px;\n\t\t\tborder-radius: 0 0 10px 10px;\n\t\t\tfont-size: 15px;\n\t\t\tdisplay: block;\n\t\t\tpadding: 10px;\n\n\t\t}\n\n\t\t.question pre.open {\n\t\t\tbackground-color: rgb(40, 40, 40);\n\t\t\tmargin: -20px 50px 20px 50px;\n\t\t\tborder-radius: 0 0 10px 10px;\n\t\t\tfont-size: 12px;\n\t\t\tdisplay: block;\n\t\t}\n\n\t\t.question .open {\n\n\t\t\tborder-radius: 10px 10px 0 0;\n\t\t}\n\n\t\tcanvas {\n\t\t\tmargin: 20px calc((100vw - 400px) / 2);\n\t\t\twidth: 400px;\n\t\t}\n\t</style>\n\n\t<!-- Container element -->\n\n\n</head>\n<script></script>\n\n<body>\n\t<div class=\"parallax\" style=\"height:100px\"></div>\n\t<h1 class=\"parallax\" style=\"height:60px\">Liam K's Tutorials</h1>\n\t<h2 class=\"parallax\" style=\"height:40px\">Platformers</h2>\n\t<div class=\"parallax\" style=\"height:100px\"></div>\n\t<h3 class=\"parallax\">Introduction</h3>\n\t<p>In 2021, I released a platformer engine tutorial that quickly became one of the top platformer engines used on KA. Now in 2024, I have decided to revamp this tutorial to make the code cleaner, more efficient, and have more capabilities. If you run into any trouble, you can contact me at <a href='https://www.khanacademy.org/profile/liamkka' target='_blank'>my Profile</a>, or just drop a question in the About section of this program.\n\t</p>\n\t<h4>What do I need to know?</h4>\n\t<p>You should at least have a rudimentary understanding of</p>\n\t<ul>\n\t\t<li><a href='https://www.khanacademy.org/computing/computer-programming/programming' target='_blank'>Intro to JS</a> </li>\n\t\t<li>OOP and method prototypes</li>\n\t\t<li>Nested arrays</li>\n\t</ul>\n\t<h4>What will this tutorial cover?</h4>\n\t<p>Among other things, this tutorial will cover\n\t<ul>\n\t\t<li>Image loading, scene management, event listener setup</li>\n\t\t<li>Collisions, some physics, animated graphics</li>\n\t\t<li>Bitmaps, level generation, Array culling, different block types</li>\n\t\t<li>Object inheritance, implementation of your features</li>\n\t\t<li>Taking your program to the next level</li>\n\n\t</ul>\n\t<h4>Getting started</h4>\n\t<p>I would suggest opening a <a href='https://www.khanacademy.org/computer-programming/new/pjs' target='_blank'>New Program</a> and coding along side me. While your could just copy and paste everything from in here, you can get so much more out of actually learning the content by typing the code yourself.</p>\n\t<p>Throughout this program, I usually give examples of code. Often, we work with nested code blocks, so I will only type out the code that is relevant at the moment. If you see ellipses (...) in code, it means that I have chosen not to show the code that is there. This does NOT mean to delete the code that is there.</p><p>I also try to thoroughly comment my code, give examples to clarify new content, and use FAQ boxes to help you understand what I'm doing. If for whatever reason I do something that is confusing, look at these resources first. If you're still confused, don't hesitate to reach out.</p>\n\t<h3 class=\"parallax\" id='setup'>Code Setup</h3>\n\n\t<p>In this section, we will write a lot of boilerplate that will help us for future sections of this program. During this part of the program, we will learn to:</p>\n\t<ul>\n\t\t<li>Use IIFEs</li>\n\t\t<li>Do scene management</li>\n\t\t<li>Create an image loading algorithm</li>\n\t\t<li>Set up player interactivity</li>\n\n\t</ul>\n\t<h4>Global Setup</h4>\n\n\t<p>Let's create some global variables that we need for our platformer. These variables should be fairly self explanatory, and I will go into more depth about each of them as they become useful.</p>\n\n\t<pre><code class=\"javascript\">var scene = \"load\";\n\nvar keys = {};\nvar click  = false;\n</code></pre>\n\n\t<h4>Scene Management Setup</h4>\n\t<p>A good scene management code is designed to be reusable in pretty much every game you create. I usually create an IIFE that contains all of the scenes that I want to use. An IIFE is an immediately invoked function expression. For example: </p>\n\n\t<pre><code class=\"javascript\">\nvar Scenes = (function(){\n\n})();\n\n//Is the same as \nvar callback = function(){\n\n};\nvar Scenes = callback();\n\n//Thanks to IA for this code bit\n</code></pre>\n\n\t<p> I prefer IIFEs because they help clean up your code. Additionally, you can store miscellaneous variables within them to avoid needing tons of global variables. For beginners, just accept that IIFEs exist and it's just another way of calling a function. Because we want to store an Object of scenes to the <code>Scenes</code> variable, you can do something like: </p>\n\n\t<pre><code class=\"javascript\">\nvar Scenes = (function(){\n    \n    return({\n        load:function(){\n        \n        },\n        play:function(){\n        \n        },\n        /*\n        In your game, you can use whatever Object keys that you want.\n        \"load\" and \"play\" are only just the ones that I use.\n        \n        Additionally, you can create however many scenes as you want.\n        If you want an instructions scene, you can add it to this object.\n        */\n        \n    });\n    \n})();\n\n//Add all of this code.\n</code></pre>\n\n\t<p>With IIFEs, the <code>return</code> keyword means that <code>Scenes</code> becomes equal to whatever is returned. Thus, Scenes is now just an Object that stores all of our scene functions. This is incredibly powerful because:</p>\n\t<pre><code class=\"javascript\">draw = function(){\n    Scenes[scene]();\n};\n//Add this code to the bottom of what you have\n</code></pre>\n\n\t<p>Means that we run whatever scene function we want simply by changing the <code>scene</code> variable. </p>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(0);\">Can you clarify how IIFEs work? </h5>\n\t\t<p>IIFEs are not super different than a normal function. The biggest difference is that they are immediately invoked, so for functions they are helpful when you only need to run a function once at the very beginning. For example, the creation of a Player Object only happens once, so we will use an IIFE for that later in this tutorial. Additionally, any variables that only are used once or twice can be compactly stored within an IIFE without stealing memory from the global namespace. We will see lots of examples of OOP used with IIFEs. By using the <code>return</code> keyword within an IIFE, we can store only the useful information globally. If you're still confused, just assume its an organizational quirk that Liam K uses to make the code more streamlined. </p>\n\t</div>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(1);\">Why do we store our scenes in an object? </h5>\n\t\t<p>Again, this is mostly an organizational quirk that Liam K uses. If you have your own method of scene management, you can feel free to use that. The one advantage is that we avoid needing to update a <code>switch/case/break</code> repetitive code structure. The Because <code>Scenes</code> is an Object that has keywords associated with different scenes, calling the function <code>Scenes.play()</code> would run the play function. <code>Scenes[scene]();</code> is the equivalent to the code above, excepting that the scene called will be based on whatever our scene variable is set to. Note that your scene variable must be set to whatever object keys you use.</p>\n\t</div>\n\t<h4>Image Loading</h4>\n\t<p>Image Loading is super useful, no matter what type of game you are making. If you are making a game, you can either use image loading, or you can make Liam cry a little bit on the inside. The basic setup that I use is as follows:</p>\n\t<pre><code class=\"javascript\">\nvar imgs = {\n    myImage:{\n        w: 100,\n        h: 100,\n        d:function(){\n            \n        },\n    },\n    mySecondImage:{\n        w: 50,\n        h: 150,\n        d:function(){\n        \n        },\n    },\n};\n\n//Include this code right above your Scenes function\n</code></pre>\n\n\t<p>Basically, all of our images will be stored within an Object. The <code>w</code> and <code>h</code> keys are the image's width and height in pixels, and the <code>d</code> key is a function that draws the image that you want. For any graphic that you want to turn into an image, you can create a new nested Object following a similar format and put the graphic's code in the <code>d</code> function. <br><br>This code is still incomplete. Inside the <code>load</code> function within our Scenes function, we need to add our image generation algorithm.</p>\n\n\t<pre><code class=\"javascript\">\n    \nvar Scenes = (function(){\n    \n    /* \n        The index of the current image that we are loading\n        \n        This variable is never used outside the loading function, so there is no need \n        to have it globally. Using IIFEs means we can clean up our code and use local \n        variables.\n    */\n    var curLoad = 0;  \n    \n    return({\n        load:function(){\n            \n            //Modified from @OOPS Studios\n            if (curLoad &#60; Object.keys(imgs).length) {\n\n\t\t//Reset Defaults\n\t\tbackground(255, 0);\n\t\tnoStroke();\n\n                //Cache the image object\n                var img = imgs[Object.keys(imgs)[curLoad]];\n                \n\t\t//Draw the image\n\t\timg.d();\n\n                //Take a snapshot and replace the image object with the actual image\n\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t//Increment to next image\n\t\tcurLoad++;\n\n\t\t//Switch to the game when done loading\n\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t    scene = 'play';\n\t\t}\n\t    }\n\t    \n\t    //Add your custom loading screen here if you want\n\t    background(0);\n\t    \n        },\n        \n        //We will use this function later\n        play:function(){\n        \n        },\n        \n    });\n    \n})();\n</code></pre>\n\n\t<p>After the Loading function is run, you now have the power to use images. Some graphics take a long time to render, so you can increase your FPS by using images. Your images can be visualized by calling:</p>\n\n\t<pre><code class=\"javascript\">// Draw our first image\nimage(imgs.myImage, x, y); \n\n//Draw our second image\nimage(imgs.mySecondImage, x, y);\n\n/*\nNotice that <code>mySecondImage</code> and <code>myImage</code> match the original object keys that we used.\nIf you tried: image(imgs.myThirdImage, x, y);, Oh Noes would get mad because \nimgs.myThirdImage does not yet exist.\n\nDon't add these lines of code, its just as an example.\n\n*/\n</code></pre>\n\n\n\t<p>If you try this on your own program, you might notice that nothing shows up. That is because if you look back at our original imgs object, you'll notice that the <code>d</code> function is empty. Let's create some real images:\n\t</p>\n\t<pre><code class=\"javascript\">\nvar imgs = {\n    ground:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0);\n        }\n    },\n    air:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0,0,0,0);\n        }\n    },\n    lava1:{\n        w:50,\n        h:50,\n        d:function(){\n            background(255,0,0);\n        }\n    },\n    lava2:{\n        w:50,\n        h:50,\n        d:function(){\n            background(235,40,0);\n        }\n    },\n    lava3:{\n        w:50,\n        h:50,\n        d:function(){\n            background(235, 86, 0);\n        }\n    },\n    player:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0,0,255);\n            \n            //Draw some eyes\n            fill(0);\n            ellipse(15, 25, 10, 20);\n            ellipse(35, 25, 10, 20);\n        }\n    },\n    portal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\n//Replace your old imgs Object. \n</code></pre>\n\t<p>You'll notice that I just used a solid background for the images. This program is not designed to teach graphics design. Rather, this tutorial should teach you the skills you need to make a basic platformer. My hope is that you learn enough to continue expanding the platformer engine and build something unique. This means for your game, please spend time developing graphics beyond my basic placeholders.</p>\n\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(2);\">If .w means width, .h means height, would .s mean size or .draw mean draw? </h5>\n\t\t<p>No. Use the format as specified. imgs.key.w and imgs.key.h only mean width and height because that's how we used them in our image loading algorithm. .w and .h have no inherent meaning other than how we define them with our code. You could theoretically format your image objects differently, but you'd have to mess around with your loading algorithm.</p>\n\t</div>\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(3);\">Can you explain Object.keys() nonsense in the loading algorithm?</h5>\n\t\t<p>Object notation is weird. Object.keys() returns an array of the object keys of a certain object. Thus, <code>Object.keys(imgs)[curLoad]</code> returns the current images key. If you are still confused, just assume that it's a quirk of JS to help us find the right image to load.</p>\n\t</div>\n\t<h4> Miscellaneous Setup</h4>\n\t<p> The following code is just some boilerplate that fixes some of the bad things about PJS. Feel free to copy/paste directly, I won't give an in depth explanation of anything. If you still have questions, reach out in the T&T.\n\n\t<pre><code class=\"javascript\">\nvar Scenes = (function(){\n    \n    var curLoad = 0;  \n    \n    /* These functions only need to be run once, so why not put them in an IIFE! */\n    \n    // KWC @mkaelin368\n    Object.constructor.prototype.new = (function() {\n        var obj = Object.create(this.prototype);\n        this.apply(obj, arguments);\n        return obj;\n    });\n        \n    // Daniel @dkareh\n    (function() {\n        return this;\n    })().LoopProtector.prototype.leave = function() {};\n    \n    //Leave as is\n    return({...});\n})();\n</code></pre>\n\n\t<h4>User interaction setup</h4>\n\t<p>First things first, we are going to setup some things that will come into use later when we do player movement.</p>\n\t<pre><code class=\"javascript\">keyPressed = function() {\n    keys[key.toString()] = true;\n    keys[keyCode] = true;\n};\nkeyReleased = function() {\n    delete keys[key.toString()];\n    delete keys[keyCode];\n};\n//Add this to the bottom of your program.\n</code></pre>\n\t<p>This code allows us to determine which keys are being pressed at any given frame. When you remove your finger from the key, it is deleted from the <code>keys</code> Object. If you want to check if a certain key is pressed, you can simply just use an if statement.</p>\n\t<pre><code class=\"javascript\">\nif(keys[LEFT]){\n    //Left arrow key\n}\n\nif(keys.w){\n    //w key\n}\n\n//Dont add this yet. Just an example\n</code></pre>\n\n\t<p>Additionally, we want to add some user interaction for clicking, in the case that you add buttons or guns to your program.</p>\n\t<pre><code class=\"javascript\">mouseClicked = function(){\n    click = true;\n};\n//Add to the bottom of your program\n</code></pre>\n\n\t<p>However, one click will make this variable always true, which isn't super helpful. You can set <code>click</code> to false every frame to fix this problem.</p>\n\n\t<pre><code class=\"javascript\">draw = function(){\n    Scenes[scene]();\n    \n    click = false;\n};\n\n//Edit your draw function. Please do not create a new draw function. \n</code></pre>\n\t<p> Now <code>click</code> is a boolean that is true only in frames that the player clicks.\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(4);\">What are the common key strokes I might need?</h5>\n\t\t<p>keys[LEFT], keys[RIGHT], keys[UP], and keys[DOWN] are the arrow keys. <br><br>keys.w, keys.a, keys.s, and keys.d are WASD. <br><br>In general, use keys.letter for any letter, and keys[##] for any special keys. The correct number (##) can be found at <a href=\"https://keycode.info\">keycode.info</a>.\n\t\t</p>\n\t</div>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(5);\">I am super confused and lost right now. Can I just copy paste the code?</h5>\n\n\t\t<pre><code class='javascript' style=\"margin-left:5px\">var scene = \"load\";\n\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n    ground:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0);\n        }\n    },\n    air:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0,0,0,0);\n        }\n    },\n    lava1:{\n        w:50,\n        h:50,\n        d:function(){\n            background(255,0,0);\n        }\n    },\n    lava2:{\n        w:50,\n        h:50,\n        d:function(){\n            background(235,40,0);\n        }\n    },\n    lava3:{\n        w:50,\n        h:50,\n        d:function(){\n            background(235, 86, 0);\n        }\n    },\n    player:{\n        w:50,\n        h:50,\n        d:function(){\n            background(0,0,255);\n            \n            //Draw some eyes\n            fill(0);\n            ellipse(15, 25, 10, 20);\n            ellipse(35, 25, 10, 20);\n        }\n    },\n    portal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\t// Daniel @dkareh\n\t(function() {\n\t\treturn this;\n\t})().LoopProtector.prototype.leave = function() {};\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad &lt; Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\t\n\tclick = false;\n};\n\nkeyPressed = function() {\n    keys[key.toString()] = true;\n    keys[keyCode] = true;\n};\nkeyReleased = function() {\n    delete keys[key.toString()];\n    delete keys[keyCode];\n};\nmouseClicked = function(){\n    click = true;\n};\n</code></pre>\n\t</div>\n\n\t<p>Congratulations, you just wrote 100 lines of boilerplate that successfully draws a black background! In the next section, we will dive into code that actually starts looking like a platformer.</p>\n\n\t<h3 class=\"parallax\">Basic Physics Body Setup</h3>\n\n\t<p>During this section, we will create a basic object constructor that will be the parent of every other object constructor in the game. We will successfully\n\n\t</p>\n\t<ul>\n\t\t<li>Learn some basic physics</li>\n\t\t<li>Create a highly adaptive parent Object Constructor</li>\n\t\t<li>Create the base code for collisions</li>\n\t</ul>\n\n\t<h4>Physics Body IIFE</h4>\n\t<p>IIFEs will be a recurring theme in this tutorial. I apologize if you don't like them. Let's create a basic object constructor with some basic methods. </p>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    var _PhysicsBody  = function(config){\n        \n    };\n    _PhysicsBody.prototype.display = function(){\n    \n    };\n    _PhysicsBody.prototype.checkColl = function(that){\n        \n    };\n    _PhysicsBody.prototype.collideX = function(){\n        \n    };\n    _PhysicsBody.prototype.collideY = function(){\n    \n    };\n    _PhysicsBody.prototype.updateX = function(){\n    \n    };\n    _PhysicsBody.prototype.updateY = function(){\n        \n    };\n    \n    return _PhysicsBody;\n})();\n//Add this directly above the Scenes function\n</code></pre>\n\n\t<p>This code includes methods for collision and movement in both the x and y directions. We will handle dimensions separately because movement in the y direction does not impact movement in the x direction, and vice versa. Separating them out will fix some common bugs in collision code. While this could be accomplished more efficiently with vectors, that is a discussion for another program. Let's go through each method and constructor individually.</p>\n\n\t<h4>Physics Body Constructor</h4>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    var _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n                \n                //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n                //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n    \n    //Code below ignored for now\n    ...\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\n\t<p>I apologize for throwing a ton of code at you out of nowhere. Let's go through step by step what everything means</p>\n\t<ul>\n\t\t<li>When we create a new instance of PhysicsBody, we will pass some JSON into the <code>config</code> argument. The code the then parses that JSON data to find the intial conditions of that instance.</li>\n\t\t<li>All of the <code>||</code> operators are used to add default values to each property. Basically <code>this.xv = config.xv || 0;</code> will default to 0 if config.xv is undefined.</li>\n\n\t\t<li>For anyone who hasn't taken a physics class, position is the point where you are, velocity is the change in position (or a speed in a certain direction), and acceleration is the change in velocity.</li>\n\t\t<li>this.imagePath is a string that matches one of the keys in the imgs object. This way, we can easily change what image is displayed for each block.</li>\n\t\t<li><code>this.solid</code> will be a boolean that determines whether or not solid collisions should be applied, or whether another object can pass through it. For example, air would not be solid, whereas a block would be.</li>\n\t</ul>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(6);\">What is the point of using <code>config</code> instead of arguments like x, y, w, h, etc?</h5>\n\t\t<p>Using config instead of many different arguments (  <code>function(config){}</code> instead of <code>function(x, y, w, h){},</code>) is always a better option. Using <code>config</code> and passing an object as a parameter allows you to order your parameters how you choose. Additionally, any unnecessary parameters can simply be left out of the config object. Both of these factors mean that using config makes your code more readable to outside people, even if using multiple arguments would achieve the same result.</p>\n\t</div>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(7);\">I don't know OOP very well. Can you explain the point of this function?</h5>\n\t\t<p>Whenever you use OOP, you create an object that contains values for any number of properties. In our program, x, yv, and maxVelocity are all examples of properties. <code>this </code> is a keyword that denotes that an indivual parameter belongs to that object. The function that we just run is called an Object Constructor function, and it is run immediately whenever a new instance (essentially a clone) of that object is created. Basically all we are doing is setting the initial conditions of the object in a way that allows us to have control over the individual values of each instance.</p>\n\t</div>\n\n\t<h4>Physics Body Display Method</h4>\n\t<p>Now we will focus on drawing the correct image for each instance of PhysicsBody. </p>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Constructor Code here\n    \n    _PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\n\t<p><code>typeof</code> is an operator that finds the type of the operand. For example: </p>\n\n\t<pre><code class='javascript'>typeof 6\n//returns \"number\"\n\ntypeof \"some string\"\n//returns \"string\"\n\ntypeof [1, 2, 3, 4]\n//returns object. Arrays are considered objects\n\n//For explanation purposes only. Do not add to your code.\n</code></pre>\n\t<p>Thus, when we only have a single string that corresponds to an object key in <code>imgs</code>, our code interprets that as a static image, while an array of strings is interpreted as a animated graphic. <br><br>The code is fairly straight forward for the static type. We simply draw the correct image at a position (x,y). Note:</p>\n\t<pre><code class='javascript'>~~this.x = ~~(this.x); //By definition. I just use ~~ because its easier to type</code></pre>\n\t<p> The code is more complex for animated case. When <code>this.imagePath</code> is equal to an array of strings, the program interprets that array as a set of images to loop through. Through the use of the modulus operator %, which returns the remainder, we can loop continuously through the <code>this.imagePath</code> array and show different images at different intervals. For example:</p>\n\t<pre><code class='javascript'>draw = function(){\n    \n    var myArray = [\"apple\", \"banana\", \"orange\"];\n    \n    println(myArray[frameCount % myArray.length]);\n    \n    //prints apple banana orange apple banana orange apple banana orange... etc.\n\n}\n//DO NOT ADD TO YOUR PROGRAM. This is an example only\n</code></pre>\n\t<p>Through this method, we can loop through different strings in an array, and display different images accordingly.</p>\n\t<h4>PhysicsBody Collision Methods</h4>\n\t<p>The following is fairly simple. We will just check to see if there is a rect-rect Collision between the two instances of the Physics Body. If they do collide, PhysicsBody.checkColl() will return true. Otherwise, it will be false. <code>that</code> is similar to <code>this</code>, except it refers to another object rather than the current object.</p>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Some code here\n    \n    \n    _PhysicsBody.prototype.checkColl = function(that){\n        return (this.x + this.w > that.x && this.y + this.h > that.y && this.x &lt; that.x + that.w && this.y &lt;that.y + that.h);\n    };\n    \n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\n\n\t<p>Rect rect collision works by analyzing the edges of each object. Contact me privately if you want a more in depth explanation. Otherwise, just assume that it works as advertised.</p>\n\n\t<h4>Collision Code</h4>\n\t<p>We need to be able to determine which side of a Physics Body that another Physics Body colldies with. We can do this by analyzing the velocity. For example, if a Body is moving left, it can only collide with the right side of an object. If you don't believe me, move your left hand to the left and try to hit your right hand. You can only do it by crossing your arms. Thus, by analyzing velocity, we can know which side the object hits. Here is some code:\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Some code here\n    \n    _PhysicsBody.prototype.collideX = function(that){\n        if(this.checkColl(that)){\n            \n            that.onCollide(this);\n        \n            if(this.xv &lt; 0) {\n                this.xv = 0;\n                this.x = that.x + that.w;\n                \n            }\n            else if(this.xv > 0) {\n                this.xv = 0;\n                this.x = that.x - this.w;\n            }\n        }\n    };\n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\t<p>Let's go through the code line by line:</p>\n\t<ol>\n\t\t<li>Make sure that the two bodies actually are colliding\n\t\t<li>Run any special function that occurs when two objects collide (ie lava killing you)\n\t\t<li>If the object's velocity is negative, it's moving left and hits the right of the other object.</li>\n\t\t<ul style=\"margin-left:0\">\n\t\t\t<li>Reset its velocity to zero.\n\t\t\t<li>Reset the object's position to the right side of the other object\n\n\n\t\t</ul>\n\t\t<li>If the object's velocity is positive, it's moving right and hits the left of the other object</li>\n\t\t<ul style=\"margin-left:0\">\n\t\t\t<li>Reset its velocity to zero.\n\t\t\t<li>Reset the object's position to the left side of the other object\n\t\t</ul>\n\n\t</ol>\n\t<p>The code is very similar in the y direction.</p>\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Some code here\n    \n    _PhysicsBody.prototype.collideY = function(that) {\n\tif (this.checkColl(that)) {\n\n\t    that.onCollide(this);\n\n\t    if (this.yv &lt; 0 && that.solid) {\n\t        this.y = that.y + that.h;\n\t        this.yv = -this.yv * 0.5;\n\t    } else if (this.yv > 0 && that.solid) {\n\t\tthis.y = that.y - this.h;\n\t        this.canJump = true;\n\t\tthis.yv = 0;\n\t    }\n\t}\n    };\n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\t<p>Let's go through the code line by line again:</p>\n\t<ol>\n\t\t<li>Make sure that the two bodies actually are colliding\n\t\t<li>Run any special function that occurs when two objects collide (ie lava killing you)\n\t\t<li>If the object's velocity is negative, it is moving upwards and collides with the bottom of another object</li>\n\t\t<ul style=\"margin-left:0\">\n\t\t\t<li>Reset the object's position to the bottom side of the other object so that it doesn't pass through\n\t\t\t<li>Make its velocity negative (ie it bounces off the bottom)\n\n\n\t\t</ul>\n\t\t<li>If the object's velocity is positive, it's moving down and hits the top of the other object</li>\n\t\t<ul style=\"margin-left:0\">\n\t\t\t<li>Reset the object's position to the top of the other object so it does not pass through\n\t\t\t<li>Allow the other object to jump again (if it is a Player or Enemy)\n\t\t\t<li>Reset the object's velocity to zero so it stops falling\n\t\t</ul>\n\n\t</ol>\n\t<h4>PhysicsBody Update Methods</h4>\n\t<p>Now we will focus on making each Body update its position each frame. This way, things like enemies and the player can move across the screen. Like before, we will start with the x direction and then extrapolate that to the y direction.</p>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Some code here\n    \n    \n    _PhysicsBody.prototype.updateX = function(){\n    \n        //Apply Friction\n        if(this.xv !== 0){\n            \n            //Slow down the velocity\n            this.xv -= Math.sign(this.xv) * this.acc;\n            if(abs(this.xv) &lt; 0.0001){\n                this.xv = 0;\n            }\n        }\n        \n        //Constrain the velocity so we don't infinitely accelerate\n        this.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n        \n        //Increment position based on velocity\n        this.x += this.xv;\n    };\n    \n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\n\t<p>The update function applies a frictional force to slow down the physics body towards zero if an opposing force is not there to counteract it. The velocity is then constrained to mimic terminal velocity, and also to avoid the condition where the Body accelerates towards infinity. Finally, the position is incremented based on velocity. Similarly in the y direction:</p>\n\n\t<pre><code class='javascript'>var PhysicsBody = (function(){\n    ... //Some code here\n    \n    \n    _PhysicsBody.prototype.updateY = function(){\n        \n        //Add a gravitational force\n        if(this.underGravity){\n            this.yv += this.acc * 2; \n        }\n        \n        //Increment position based on velocity\n        this.y += this.yv;\n    };\n    \n    \n    ... //Other methods here\n    \n})();\n//Please edit your existing PhysicsBody function rather than copy pasting a new one in\n</code></pre>\n\n\t<p>The biggest difference is that we replace a frictional force with a gravitational force, which simply accelerates the Body downwards.</p>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(8);\">Wait a minute, how are you calculating friction?</h5>\n\t\t<p>Friction is a force that always opposed the direction of motion. By finding the sign of the velocity (either +1 or -1), we can know its direction. The player is then accelerated in the opposite direction until its velocity approaches zero. While this method does not follow the real laws of physics, it makes a good enough approximation for our purposes.</p>\n\t</div>\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(9);\">I got lost somewhere in the middle. Can I see the code so far?</h5>\n\t\t<pre><code class='javascript' style=\"margin-left:5px\">var scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x &lt; that.x + that.w && this.y &lt; that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv &lt; 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv &lt; 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) &lt; 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\t// Daniel @dkareh\n\t(function() {\n\t\treturn this;\n\t})().LoopProtector.prototype.leave = function() {};\n\n\treturn ({\n\t    load: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad &lt; Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\t\n\tclick = false;\n};\n\nkeyPressed = function() {\n    keys[key.toString()] = true;\n    keys[keyCode] = true;\n};\nkeyReleased = function() {\n    delete keys[key.toString()];\n    delete keys[keyCode];\n};\nmouseClicked = function(){\n    click = true;\n};\n\n\n</code></pre>\n\n\t</div>\n\n\t<p>A few hundred lines of code in and it does absolutely nothing! At this point you may be wondering why haven't we created blocks, players, levels, or anything else that would be particularly useful in a platformer engine. The answer is, by applying a little bit of JS magic, we can turn the Physics Body code into all of the above. We will discuss that further in the next few sections.</p>\n\n\t<h3 class=\"parallax\">Level Setup</h3>\n\t<p>After only writing boilerplate, let's move onto something that looks a bit more like a platformer. Designing levels is one of the most important parts of a platformer, so let's take a look at that problem now. During this section, we will learn</p>\n\t<ul>\n\t\n\t    <li>How to use bitmaps and create levels</li>\n\t    <li>How to use an array culling algorithm and why it's so powerful</li>\n\t    <li>Add support for different block types</li>\n\t    <li>Finally get something to show up</li>\n\t</ul>\n\n\t<h4>Levels IIFE</h4>\n\t<p>You guessed it, more IIFEs for our levels and world.</p>\n\n\t<pre><code class='javascript'>\nvar Player = function(){};\n\t\nvar World = (function(){\n    var _World = {\n        currentLevel:0,\n        \n        blockSize:50, \n        \n        bitmaps: [],\n        level:[],\n        \n    };  \n    \n    return _World;\n})();\n//Add this directly above the Scenes function\n</code></pre>\n\n\t<p>The above code defines some basic variables that we need. World.currentLevel and World.blockSize are self explanatory. World.bitmaps is an array that will hold representations of each level, while World.level will hold block objects for the current level. Let's focus on the bitmaps first.<br><br>We will also define the Player object constructor to fix a bug later on. We will come back and work on the player later.</p>\n\n\t<pre><code class='javascript'>\nvar World = (function(){\n    var _World = {\n        currentLevel:0,\n        \n        blockSize:0,\n        \n        bitmaps: [\n        \t[\n        \t\t\"############\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#-------@--#\",\n        \t\t\"#-P-----#--#\",\n        \t\t\"#----#-----#\",\n        \t\t\"#-#------#l#\",\n        \t\t\"#---l-#--ll#\",\n        \t\t\"############\"\n        \t],\n        \t[\n        \t\t\"############\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#-P--------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"#----------#\",\n        \t\t\"############\"\n        \t],\n        ],\n        level:[],\n    };  \n    \n    return _World;\n})();\n//Please only change the new code. \n</code></pre>\n\n\t<p>Each level bitmap is a 12x12 grid of characters that represents each level. In this case, # represents blocks, - represents air, l represents lava, P represent the player spawn, and @ represents a portal. There is nothing special about these characters. You can choose whichever characters that you want as long as you are consistent. I personally just think that those characters are easily visualized so you can tell which block is which.</p>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(10);\">Do I have to use a 12x12 grid?</h5>\n\t\t<p>Nope! You can make your levels any size or shape that you want. This tutorial will eventually add support for almost infinitely sized maps with zero lag. However, I would recommend sticking with a 12x12 grid until we add a camera.</p>\n\t</div>\n\t<p>Now we will add support for different block types</p>\n\n\t<pre><code class='javascript'>\nvar World = (function(){\n    \n    var _World = {\n        ... //Lots of Code in here, not relevant at the moment\n    };  \n    \n    //Make sure that your object keys match the characters within your bitmap\n    _World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n    return _World;\n})();\n//Please only change the new code. \n</code></pre>\n\t<p>Whenever you create a new block type, you need to go back to this code and create a new nested object for that type. Note that each object key corresponds to a character within the bitmap. <code>imagePath </code> will be passed into the config object, and its usage is the same as the PhysicsBody.imagePath. <code>solid</code> determines whether or not the player will collide with the block. <code>onCollide</code> is a function that is called on collision. We will eventually sort our blocks by their <code>collPriority</code> so we have more control over which collisions occur first.</p>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(11);\">I added it to my program, why don't I see blocks show up?</h5>\n\t\t<p>Objects are just ways of storing data. We have to tell the program to use the data to create blocks, which we will accomplish in the next step of this program. </p>\n\t</div>\n\n\t<h4>Level Generation</h4>\n\t<p>To successfully create blocks, we must loop through our bitmap and create a block for each character.</p>\n\t<pre><code class='javascript'>\nvar World = (function(){\n    \n    var _World = {\n        ... //Lots of Code in here, not relevant at the moment\n    };  \n    \n    _World.blockTypes = {\n        ... //Just assume this code is still here\n    };\n    \n    _World.generateLevel = function(){\n        \n        _World.level = [];\n        \n        for(var i = 0; i &lt; _World.bitmaps[_World.currentLevel].length; i ++){\n            \n            var columnArray = [];\n            \n            for(var j = 0; j &lt; _World.bitmaps[_World.currentLevel][i].length; j ++){\n                \n                var currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n                \n                if(currentType.onSpawn){\n\t\t    currentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t}\n                \n                columnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n            }\n            \n            _World.level.push(columnArray);\n        }\n    };\n    \n    return _World;\n})();\n//Please only change the new code. \n</code></pre>\n\t<p>If you're confused, that's absolutely understandable. Let's go through line by line starting at our new code and see what everything does.</p>\n\t<ul>\n\t    <li>Clear the old level away</li>\n\t\t<li>Loop through the current level's bitmap vertically</li>\n\t    <ul style=\"margin-left:0\">\n\t\t\n\t\t\n\t\t<li>Create a temporary array to store that column's blocks</li>\n\t\t<li>Loop through the current column's blocks</li>\n\t\t<ul style=\"margin-left:0\">\n\t\t    <li>Find the current type in <code>_World.blockTypes</code>. This is accomplished with the fact that each blockTypes key matches a character in the bitmap\n\t\t    <li>If there is a special function to be run on spawn (ie Player spawn) do  that function.</li>\n\t\t    <li>Add a new block to the temporary column array</li>\n\t\t</ul>\n\t\t<li>Push the entire array of newly created blocks into the .level array</li>\n\t\t    \n\t\t</ul>\n\t</ul>\n\t<p>Creating a temporary array is important because it allows us to create a 2D array, which keeps the block's position relative to each other the same. We will capitalize on the 2D nature of the array in the next step.</p>\n\t<h4>Array Culling Algorithm</h4>\n\n\t<p>Instead of looping through every single block on the screen to display it and check collisions, we can simply use an array culling algorithm to only look at the blocks within a certain proximity. Rather than checking distance to every block, THE ALGORITM CAN IGNORE EVERY BLOCK THAT IS IRRELEVANT. Meaning, infinitely sized levels are a possibility. I have tested collisions with ~500,000 blocks with no noticeable lag. The algorithm works as follows: </p>\n\n\t<pre><code class='javascript'>\nvar World = (function(){\n    \n    var _World = {\n        ... //Lots of Code in here, not relevant at the moment\n    };  \n    \n    _World.blockTypes = {\n        ... //Just assume this code is still here\n    };\n    \n    _World.generateLevel = function(){\n        ... //Again, pretend its here\n    };\n    \n    //An algorithm to find a subset of an 2D array\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i &lt; endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j &lt; endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n    return _World;\n})();\n//Please only change the new code. \n</code></pre>\n\t<p>Is your head spinning with this one? Don't worry too much if its a little complicated. I will do my best to explain. Because every block is the same fixed width, dividing the x and y positions by the width will give an approximation of the index of the block within the array of the bitmap. Rounding this calculated value down will give an integer number <i>that is the index within the bitmap</i>. By starting at a position, and looping over a fixed width and height (also converted into index units), the algorithm essentially isolates a subset of a larger array, <i>without considering the larger array</i>. For example:</p>\n\n\t<pre><code class='javascript'>\n/*\nLets pretend that we have a grid of blocks, with each block having a width \nof 10 pixels, and the Player P being at position (33, 46). The only blocks\nthat the player could could conceivably collide with is the 3x3 array surrounding \nit. Thus, we can use the World.cullArray() function to create a subset of the \nlarger level array. The algorithm would convert the position (33, 46) into the \nindex values of (3, 4). The algorithm would then start looping at (2,3) and \nincrement indexX and indexY values until it reached (4,5). In all, only 9\nblocks are considered, while the other blocks ae ignored. This algorithm can\nalso be applied to only displaying blocks that are on the screen.\n\n---------------\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|P|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|_|\n\nDo not add. For example purposes only\n*/\n</code></pre>\n\t<p>If you still have questions, don't hesitate to reach out.</p>\n\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(12);\">What's the deal with the max and min functions in the algorithm?</h5>\n\t\t<p>I use max/min as a way to limit the indices to values that are defined. Oh Noes becomes unhappy if you try to access values in an array that aren't there. <code>max(startX, 0)</code> means that the code will use whichever number is bigger, so if startX is less than 0, the program starts looping at 0.</p>\n\t</div>\n\n\t<h4>Display code</h4>\n\t<p>Now all that's left to do is to display the blocks. I won't go super into detail on this function, because we will change it later to implement array culling.</p>\n\t<pre><code class='javascript'>var World = (function(){\n\t\n    ... //lots of code here\n\n    _World.display = function(){\n        for(var i = 0; i &lt; this.level.length; i ++){\n            for(var j = 0; j &lt; this.level[i].length; j ++){\n                this.level[i][j].display();\n            }\n        }  \n    };\n    \n    return _World;\n    \n})();\n</code></pre>\n\t<p>All that this code does is to loop through the level array vertically and horizontally, displaying the block at each location. Finally, to implement the code, we need to make a few small changes elsewhere in your code. </p>\n\n\t<pre><code class='javascript'>\nvar Scenes = (function() {\n\n\t... //some code ehre\n\n\treturn ({\n\t    load: function() {\n\t\t//Modified from @OOPS Studios\n\t\tif (curLoad &lt; Object.keys(imgs).length) {\n\t\t\n\t\t    //Reset Defaults\n\t\t    background(255, 0);\n\t\t    noStroke();\n\t\t    \n\t\t    //Cache the image object\n\t\t    var img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t    //Draw the image\n\t\t    img.d();\n\n\t\t        //Take a snapshot and replace the image object with the actual image\n\t\t        imgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t        //Increment to next image\n\t\t        curLoad++;\n\n\t\t        //Switch to the game when done loading\n\t\t        if (curLoad === Object.keys(imgs).length) {\n\t\t\t    scene = 'play';\n\t\t\t    World.generateLevel(); //ADDED CODE\n\t\t\t}\n\t\t    }\n\n\t\t    //Add your custom loading screen here if you want\n\t\t    background(0);\n\t\t},\n\n\t\tplay: function() {\n\t\t    //ADDED CODE\n\t\t    background(255);\n\t\t    World.display();\n\t\t},\n\t});\n\n})();\n</code></pre>\n\t<p>The only code that we added is one line in the <code>load</code> function that implements our .generateLevel function, and another line in the <code>play</code> function that displays our blocks. And voila! Just like that, with slightly under 400 lines of code, we have successfully created a glorified pixel art. If your code is working correctly, it should look something like:</p>\n\n\t<canvas id=\"mycanvas\"></canvas>\n\t<script type>\n\t\tvar programCode = function(processingInstance) {\n\t\t\twith(processingInstance) {\n\t\t\t\tsize(600, 600);\n\t\t\t\tframeRate(60);\n\n\n\n\n\t\t\t\tvar scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x < that.x + that.w && this.y < that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv < 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv < 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) < 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Player = function(){};\n\nvar World = (function() {\n\n\tvar _World = {\n\t\tcurrentLevel: 0,\n\n\t\tblockSize: 50,\n\n\t\t\tbitmaps: [\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-------@--#\",\n\t\t\t\t\"#-P-----#--#\",\n\t\t\t\t\"#----#-----#\",\n\t\t\t\t\"#-#------#l#\",\n\t\t\t\t\"#---l-#--ll#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-P--------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t],\n\t\t\n\t\tlevel: [],\n\t};\n\n\t_World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n\n\t_World.generateLevel = function() {\n\n\n\t\t_World.level = [];\n\n\t\tfor (var i = 0; i < _World.bitmaps[_World.currentLevel].length; i++) {\n\n\t\t\tvar columnArray = [];\n\n\t\t\tfor (var j = 0; j < _World.bitmaps[_World.currentLevel][i].length; j++) {\n\n\t\t\t\tvar currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n\t\t\t\t\n\t\t\t\tif(currentType.onSpawn){\n\t\t\t\t    currentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t\t\t}\n\n\t\t\t\tcolumnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n\n\t\t\t}\n\n\t\t\t_World.level.push(columnArray);\n\t\t}\n\t};\n\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i < endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j < endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n\n\t_World.display = function() {\n\t\tfor (var i = 0; i < this.level.length; i++) {\n\t\t\tfor (var j = 0; j < this.level[i].length; j++) {\n\t\t\t\tthis.level[i][j].display();\n\t\t\t}\n\t\t}\n\t};\n\n\treturn _World;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\t\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad < Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t\tWorld.generateLevel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\t\t\tbackground(255);\n\n\t\t\tWorld.display();\n\n\t\t\t\n\t\t},\n\t});\n\n})();\n\n\ndraw = function() {\n\tScenes[scene]();\n\n\n\tclick = false;\n};\n\nkeyPressed = function() {\n\tkeys[key.toString()] = true;\n\tkeys[keyCode] = true;\n};\nkeyReleased = function() {\n\tdelete keys[key.toString()];\n\tdelete keys[keyCode];\n};\nmouseClicked = function() {\n\tclick = true;\n};\n\t\t\t}\n\t\t};\n\n\t\t// Get the canvas that ProcessingJS will use\n\t\tvar canvas = document.getElementById(\"mycanvas\");\n\t\t// Pass the function to ProcessingJS constructor\n\t\tvar processingInstance = new Processing(canvas, programCode);\n\t</script>\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(13);\">Why are some blocks cut off?</h5>\n\t\t<p>Make sure that your canvas size is 600x600. You can add ?width=600&height=600 to the end of your new program to fix this problem.</p>\n\n\t</div>\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(14);\">My code broke. Can I see the correct solution?</h5>\n\t\t<pre><code class='javascript' style=\"margin-left:5px\">\nvar scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x &lt; that.x + that.w && this.y &lt; that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv &lt; 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv &lt; 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) &lt; 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Player = function(){};\n\nvar World = (function() {\n\n\tvar _World = {\n\t\tcurrentLevel: 0,\n\n\t\tblockSize: 50,\n\n\t\tbitmaps: [\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-------@--#\",\n\t\t\t\t\"#-P-----#--#\",\n\t\t\t\t\"#----#-----#\",\n\t\t\t\t\"#-#------#l#\",\n\t\t\t\t\"#---l-#--ll#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-P--------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t],\n\t\t\n\t\tlevel: [],\n\t};\n\n\t_World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n\n\t_World.generateLevel = function() {\n\n\n\t\t_World.level = [];\n\n\t\tfor (var i = 0; i &lt; _World.bitmaps[_World.currentLevel].length; i++) {\n\n\t\t\tvar columnArray = [];\n\n\t\t\tfor (var j = 0; j &lt; _World.bitmaps[_World.currentLevel][i].length; j++) {\n\n\t\t\t\tvar currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n\t\t\t\t\n\t\t\t\tif(currentType.onSpawn){\n\t\t\t\t    currentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t\t\t}\n\n\t\t\t\tcolumnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n\n\t\t\t}\n\n\t\t\t_World.level.push(columnArray);\n\t\t}\n\t};\n\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i &lt; endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j &lt; endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n\n\t_World.display = function() {\n\t\tfor (var i = 0; i &lt; this.level.length; i++) {\n\t\t\tfor (var j = 0; j &lt; this.level[i].length; j++) {\n\t\t\t\tthis.level[i][j].display();\n\t\t\t}\n\t\t}\n\t};\n\n\treturn _World;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\t\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\t// Daniel @dkareh\n\t(function() {\n\t\treturn this;\n\t})().LoopProtector.prototype.leave = function() {};\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad &lt; Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t\tWorld.generateLevel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\t\t\tbackground(255);\n\n\t\t\tWorld.display();\n\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\n\tclick = false;\n};\n\nkeyPressed = function() {\n\tkeys[key.toString()] = true;\n\tkeys[keyCode] = true;\n};\nkeyReleased = function() {\n\tdelete keys[key.toString()];\n\tdelete keys[keyCode];\n};\nmouseClicked = function() {\n\tclick = true;\n};\n\n\n\n</code></pre>\n\n\t</div>\n\n\t<h3 class=\"parallax\">Player Object</h3>\n\n\t<p>While slightly animated pixel art is nice, it is now time to work on expanding user interactivity by creating a Player. In this section, we will learn to</p>\n\t<ul>\n\t\t<li>implement Object Inheritance</li>\n\t\t<li>Put our event listeners to good use</li>\n\t\t<li>Implement collisions and the array culling algorithm</li>\n\t</ul>\n\t<h4>Player Object Constructor</h4>\n\t<p>We worked super hard to create the Physics Body. We can use Object Inheritance to give the Player all of the same properties and methods as the PhysicsBody. Again, we will use IIFEs as an organizational technique.</p>\n\t<pre><code class='javascript'>\nvar Player = (function() {\n\n\tvar _Player = function(config){\n\t    PhysicsBody.call(this, config);\n\t};\n\t_Player.prototype = Object.create(PhysicsBody.prototype);\n\t\n\treturn new _Player({\n\t\tx: 100,\n\t\ty: 100,\n\t\tw: 50,\n\t\th: 50,\n\t\timagePath: \"player\",\n\t});\n\n})();\n</code></pre>\n\t<p>By using two new lines of code, the Player Object essentially makes itself a copy of a new PhysicsBody. <code>PhysicsBody.call(this, config)</code> runs all of the code in the PhysicsBody Object Constructor, while <code>_Player.prototype = Object.create(PhysicsBody.prototype); </code> copies all of the methods from Physics Body. In other words, running <code>Player.display();</code> would run all of the code for <code>PhysicsBody.display()</code>, and we avoid needing to retype all of the same code again. I returned a new _Player rather than the entire _Player class because we will only ever need one Player.</p>\n\t<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(15);\">Why is Object Inheritance useful?</h5>\n\t\t<p>You'll notice that each block is just a Physics Body. The Player is a copy of a Physics Body. In your program, you could choose to implement enemies that are children of the Physics Body. Each new class only differs from the parent PhysicsBody by a few lines of code. In the case of the Player, we'll add user inputs for control. You can save time and energy while also making your code more readable by using Object Inheritance.</p>\n\n\t</div>\n\t<h4>Adding Event Listeners</h4>\n\t<p>What is a player without key inputs for movement? Let's focus on adding some event listeners for Player movement.\n\t<pre><code class='javascript'>\nvar Player = (function() {\n    \n        //Leave these as they are\n\tvar _Player = function(config){\n\t    PhysicsBody.call(this, config);\n\t};\n\t_Player.prototype = Object.create(PhysicsBody.prototype);\n\t\n\t//This code is new\n\t_Player.prototype.handleKeys = function(){\n\t\n\t    //Horizontal Movement\n\t    if (keys[LEFT] || keys.a) {\n\t        this.xv -= this.acc * 3;\n\t    } else if (keys[RIGHT] || keys.d) {\n\t        this.xv += this.acc * 3;\n\t    }\n\t    \n\t    //Jumping\n\t    if ((keys[UP] || keys.w) && this.canJump) {\n\t        this.yv = -this.maxVelocity * 2;\n\t        this.canJump = false;\n            }\n\t};  \n\t\n\t... //some code\n\n\n})();\n</code></pre>\n\n<p>We already learned how to use key inputs. Let's go step by step again to see what happened in the <code>.handleKeys</code> method.\n<ul>\n    <li>Check if the Left arrow or the \"a\" key is pressed</li>\n    <ul style = \"margin-left:0\">\n        <li>If so, accelerate towards the left\n    </ul>\n    <li>Check if the Right arrow or the \"d\" key is pressed</li>\n    <ul style = \"margin-left:0\">\n        <li>If so, accelerate to the right\n    </ul>\n    <li>Check to see if the Up Arrow or the \"w\" key is pressed, making sure that the Player recently touched the top of a block to eliminate the Player's ability to fly.</li>\n    <ul style = \"margin-left:0\">\n    <li>If so, set a high upwards velocity\n    <li>Remove the ability to jump until it touches the top of another block\n    </ul>\n</ul>\n<h4>Implementing the Player</h4>\n<p>Now all that's left is to implement all of the code we just created so the Player can move around in the frame. Inside the <code>play</code> function, add this code to our <code>World</code> function:</p>\n<pre><code class='javascript'>\nWorld = (function(){\n\n    ... //A ton of methods right here\n    \n    _World.sortCollPriority = function(a,b){\n        return(b.collPriority - a.collPriority);\t\n    };\n\t\n})();\n</code></pre>\n<p>This code bit will be used to help us sort our blocks based on their priority for collision. For this tutorial, we made all blocks have the same priority except for lava to eliminate the bug of colliding prematurely with lava while moving left. In your program, you may need to adjust the values of <code>.collPriority</code> if you create any new block types.</p><p>Assuming that parameters <code>a</code> and <code>b</code> are two different blocks, the <code>Array.prototype.sort</code> function will determine which block has a higher priority and sort that block in front of blocks with a lower priority.</p>\n<pre><code class='javascript'>play:function(){\n    background(255);\n    World.display();\n    \n    //NEW CODE\n    Player.handleKeys();\n\n    //Run the cull array algoritm to find a subset of blocks to check collisions against\n    var collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n\n    //Move the player in the x direction\n    Player.updateX();\n    \n    //Loop through the culled array and run collisions with those blocks\n    for (var i = 0; i &lt; collBox.length; i++) {\n    \n        //Sort the blocks\n        collBox[i].sort(World.sortCollPriority);\n    \n    \tfor (var j = 0; j &lt; collBox[i].length; j++) {\n    \t    Player.collideX(collBox[i][j]);\n    \t}\n    }\n},\n</code></pre>\n<p>The array culling algorithm is used for collisions for reasons aforementioned. We will store the new culled array in the variable <code>collBox</code> for easy reuse. This code only updates and collides in the x dimension. Similarly for the y direction:</p>\n<pre><code class='javascript'>play:function(){\n    background(255);\n    World.display();\n    \n    Player.handleKeys();\n\n    //Run the cull array algoritm to find a subset of blocks to check collisions against\n    var collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n\n    //Move the player in the x direction\n    Player.updateX();\n    \n    //Loop through the culled array and run collisions with those blocks\n    for (var i = 0; i &lt; collBox.length; i++) {\n    \n        //Sort the blocks\n        collBox[i].sort(World.sortCollPriority);\n    \n    \tfor (var j = 0; j &lt; collBox[i].length; j++) {\n    \t    Player.collideX(collBox[i][j]);\n    \t}\n    }\n    \n    //Do the same thing in the Y direction.  \n    Player.updateY();\n    for (var i = 0; i &lt; collBox.length; i++) {\n        for (var j = 0; j &lt; collBox[i].length; j++) {\n            Player.collideY(collBox[i][j]);\n        }\n    }\n    \n    //Display the player.\n    Player.display();\n},\n</code></pre>\n<p>You'll notice that the code is almost identical for the y direction. We do not need to re-sort the blocks because we are using the same array, which was already sorted for us by the x-direction code. Make sure to also run the <code>Player.display();</code> method so you can see the player. Your output should now be an almost fully functioning Platformer.</p> \n\n<canvas id=\"mycanvas2\"></canvas>\n\t<script type>\n\t\tvar programCode = function(processingInstance) {\n\t\t\twith(processingInstance) {\n\t\t\t\tsize(600, 600);\n\t\t\t\tframeRate(60);\n\n\nvar scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x < that.x + that.w && this.y < that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv < 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv < 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) < 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Player = (function() {\n\n\tvar _Player = function(config) {\n\t\tPhysicsBody.call(this, config);\n\t};\n\t_Player.prototype = Object.create(PhysicsBody.prototype);\n\n\t_Player.prototype.handleKeys = function() {\n\n\t\tif (keys[LEFT] || keys.a) {\n\t\t\tthis.xv -= this.acc * 3;\n\t\t} else if (keys[RIGHT] || keys.d) {\n\t\t\tthis.xv += this.acc * 3;\n\n\t\t}\n\t\tif ((keys[UP] || keys.w) && this.canJump) {\n\t\t\tthis.yv = -this.maxVelocity * 2;\n\t\t\tthis.canJump = false;\n\t\t}\n\t};\n\treturn new _Player({\n\t\tx: 100,\n\t\ty: 100,\n\t\tw: 50,\n\t\th: 50,\n\t\timagePath: \"player\",\n\t});\n\n})();\n\nvar World = (function() {\n\n\tvar _World = {\n\t\tcurrentLevel: 0,\n\n\t\tblockSize: 50,\n\n\t\t\tbitmaps: [\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-------@--#\",\n\t\t\t\t\"#-P-----#--#\",\n\t\t\t\t\"#----#-----#\",\n\t\t\t\t\"#-#------#l#\",\n\t\t\t\t\"#---l-#--ll#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-P--------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t],\n        \n\t\tlevel: [],\n\t};\n\n\t_World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n\n\t_World.generateLevel = function() {\n\n\n\t\t_World.level = [];\n\n\t\tfor (var i = 0; i < _World.bitmaps[_World.currentLevel].length; i++) {\n\n\t\t\tvar columnArray = [];\n\t\t\t\n\t\t\t\n\n\t\t\tfor (var j = 0; j < _World.bitmaps[_World.currentLevel][i].length; j++) {\n\n\t\t\t\tvar currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n\n\n                if (currentType.onSpawn) {\n\t\t\t\t\tcurrentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcolumnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n\n\t\t\t}\n\n\t\t\t_World.level.push(columnArray);\n\t\t}\n\t};\n\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i < endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j < endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n\n\t_World.display = function() {\n\t\tfor (var i = 0; i < this.level.length; i++) {\n\t\t\tfor (var j = 0; j < this.level[i].length; j++) {\n\t\t\t\tthis.level[i][j].display();\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_World.sortCollPriority = function(a,b){\n\t    return(b.collPriority - a.collPriority);\t\n\t};\n\n\treturn _World;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\t\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad < Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t\tWorld.generateLevel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\t\t\tbackground(255);\n\t\t\tWorld.display();\n\n\t\t\tPlayer.handleKeys();\n\n\t\t\tvar collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n\n\t\t\tPlayer.updateX();\n\t\t\t//Loop through the culled array and run collisions with those blocks\n            for (var i = 0; i < collBox.length; i++) {\n            \n                //Sort the blocks\n                collBox[i].sort(World.sortCollPriority);\n            \n            \tfor (var j = 0; j < collBox[i].length; j++) {\n            \t    Player.collideX(collBox[i][j]);\n            \t}\n            }\n\n\t\t\tPlayer.updateY();\n\t\t\tfor (var i = 0; i < collBox.length; i++) {\n\t\t\t\tfor (var j = 0; j < collBox[i].length; j++) {\n\t\t\t\t\tPlayer.collideY(collBox[i][j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPlayer.display();\n\t\t\t\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\n\tclick = false;\n};\n\nkeyPressed = function() {\n\tkeys[key.toString()] = true;\n\tkeys[keyCode] = true;\n};\nkeyReleased = function() {\n\tdelete keys[key.toString()];\n\tdelete keys[keyCode];\n};\nmouseClicked = function() {\n\tclick = true;\n};\n\n\t\t\t}\n\t\t};\n\n\t\t// Get the canvas that ProcessingJS will use\n\t\tvar canvas = document.getElementById(\"mycanvas2\");\n\t\t// Pass the function to ProcessingJS constructor\n\t\tvar processingInstance = new Processing(canvas, programCode);\n\t</script>\n\t\n<h3 class=\"parallax\">Added Functionality</h3>\n<p>During this section, we will discuss taking your game to the next level. We will add:</p>\n<ul>\n    <li>Larger Maps</li>\n    <li>A camera function</li>\n    <li>Advice for the future</li>\n</ul>\n<h4>Larger Levels and the Camera</h4>\n<p>Let's make a larger level so that we can implement the array culling algorithm to the block draw loop. Inside your <code>World</code> function, change your level bitmaps to:</p>\n\n<pre><code class='javascript'>\n//All of this code takes place inside the World object.\nbitmaps: [\n    [\n    \t\"------------------------------------\",\n    \t\"------------------------------------\",\n    \t\"----------#ll#----------------------\",\n    \t\"--P-----#-####------#-----##--------\",\n    \t\"-----#-----------#------#####-------\",\n    \t\"--#------#l-------------------------\",\n    \t\"----l-#--ll------lllllllllllll--@---\",\n    \t\"#####################################\"\n    ],\n    [\n    \t\"############\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#-P--------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"#----------#\",\n    \t\"############\"\n    ],\n],\n</code></pre>\n<p>Hopefully this change should be self explanatory. All we are doing is making the level larger. The positioning of blocks does not need to be exact. As you'll notice, many of the blocks are cut off. This is why we need to implement a <code>Camera</code> Object to follow the player. A camera in a game is basically just a way to use matrix transformations (translate, push/popMatrix) to follow the player around. The entire canvas is translated so that the player is in the middle of the screen. Right above your PhysicsBody class and below your images object, add the following:</p>\n<pre><code class='javascript'>\nvar Camera = (function(){\n    var _Camera = {\n        x:0,\n        y:0,\n        scale:1,\n    };\n    \n    _Camera.startLink = function(){\n        \n    };\n    \n    _Camera.endLink = function(){\n        \n    };\n    \n    _Camera.follow = function(that){\n        \n    };\n    \n    _Camera.shake = function(){\n        \n    };\n    \n    _Camera.zoomTo = function(scl){\n        \n    };\n    \n    \n    return _Camera;\n})();\n</code></pre>\n<p>Again, there is nothing revolutionary about this code. All we are doing is setting up a Camera Object with various associated methods and properties. Now we'll go through each of those methods in depth.</p>\n<pre><code class='javascript'>\nvar Camera = (function(){\n    \n    ... //Some code here\n    \n    _Camera.startLink = function(){\n        pushMatrix();\n    };\n    \n    _Camera.endLink = function(){\n        popMatrix();\n    };\n    \n    ... //More code here\n})();\n</code></pre>\n<p><code>.startLink</code> and <code>.endLink</code> are two methods that I use to denote which objects are followed by the camera. Anything outside of them will be fixed on the screen. This is particularly helpful for things like health bars and other stats. </p>\n<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(16);\">Why do you even need .startLink and .endLink methods if it is just push/popMatrix?</h5>\n\t\t<p>You could technically avoid using these methods and instead opt for push/popMatrix in their place, seeing absolutely no difference. This is mostly just one of Liam's organizational quirks. In my programs, I sometimes might have two or three other nested push/popMatrices, so running <code>Camera.startLink()</code> makes it easier to determine what exactly the camera is doing.</p>\n\n\t</div>\n\t<p>Moving on to the <code>.follow</code> method where most of the action happens, we get the following:</p>\n\t<pre><code class='javascript'>\nvar Camera = (function(){\n    \n    ... //Some code here\n    \n    Camera.follow = function(that){\n    \n        //lerp the object to the center of the screen\n        this.x = lerp(this.x, width / 2 - (that.x + that.w / 2) * this.scale, 0.1);\n        this.y = lerp(this.y, height / 2 - (that.y + that.h / 2) * this.scale, 0.1);\n        \n        //transformations\n        translate(~~this.x, ~~this.y);\n        \n        //Scale the camera correctly\n        translate(width/2, height/2);\n        scale(this.scale);\n        translate(-width/2, -height/2);\n    \n    };\n    \n    ... //More code here\n})();\n</code></pre>\n<p>Let's go through and see what code we just added:</p>\n<ul>\n    <li>The argument <code>that</code> is just the Object to follow. Usually we follow the Player, but any other object can be followed as long as it has x, y, w, and h properties.</li>\n    <li>lerp is used to smoothly translate the camera towards the player</li>\n    <ul style=\"margin-left:0\">\n        <li>The mathy looking part is just a way to find where the middle of the Player is in pixels, and then move the Camera to center on that spot.</li>\n        <li>Two lerp functions are used for both the x and y directions</li>\n    </ul>\n    <li>We translate the camera to the correct place</li>\n    <li>We scale the camera correctly. By translating to the middle of the screen, we make the origin from which the Camera is scaled the middle of the screen rather than the coordinate (0,0). If we didn't translate to the middle of the screen, zooming in would zoom in on the top left, and the Player might fall out of view.</li>\n</ul>\n\n<pre><code class='javascript'>\nvar Camera = (function(){\n    \n    ... //Some code here\n    \n    _Camera.shake = function(){\n        this.x += random(-5, 5);\n        this.y += random(-5, 5);\n    };\n    \n    _Camera.zoomTo = function(scl){\n        this.scale = lerp(this.scale, scl, 0.1);\n    };\n    \n    ... //More code here\n})();\n</code></pre>\n\n<p>These are miscellaneous camera functions that you may choose to use, or you may forget completely about them and never use them. Both of them do exactly what you would expect they would. <code>.shake</code> translates the camera randomly, and could be used for juicing up your collisions. <code>.zoomTo</code> changes the scale to zoom in on the Player. I will  likely not implement them in this tutorial, but you can feel free to play around with them. Now let's implement these in our code:</p>\n\n<pre><code class='javascript'>\n//All of this takes place within the Scenes function.\nplay: function() {\n\t\t    \n    //Anything above the startLink method will be fixed on the screen\n    Camera.startLink();\n    Camera.follow(Player);\n    \n    background(255);\n    World.display();\n    \n    Player.handleKeys();\n    \n    var collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n    \n    Player.updateX();\n    //Loop through the culled array and run collisions with those blocks\n    for (var i = 0; i &lt; collBox.length; i++) {\n    \n        //Sort the blocks\n        collBox[i].sort(World.sortCollPriority);\n    \n    \tfor (var j = 0; j &lt; collBox[i].length; j++) {\n    \t    Player.collideX(collBox[i][j]);\n    \t}\n    }\n    \n    Player.updateY();\n    for (var i = 0; i &lt; collBox.length; i++) {\n    \tfor (var j = 0; j &lt; collBox[i].length; j++) {\n    \t\tPlayer.collideY(collBox[i][j]);\n    \t}\n    }\n    \n    Player.display();\n    \n    Camera.endLink();\n    //Anything below the endLink method will be fixed on the screen\n    \n},\n</code></pre>\n<p>As you can see, we have kept the same code as before, but simply added three lines to call the <code>Camera</code> methods.</p>\n<h4>Adding Array Culling</h4>\n<p>Like we did for the collisions, we can use array culling in our  <code>World.display()</code> algorithm to only display the blocks on the canvas. In our <code>_World.display</code> function inside the <code>World</code> IIFE, let's do the following:</p>\n<pre><code class=\"javascript\">//Replace the old _World.display function\n_World.display = function() {\n    \n    var displayBox = _World.cullArray(this.level, -Camera.x - _World.blockSize, -Camera.y - _World.blockSize, width + _World.blockSize * 2, height + _World.blockSize * 2);\n    \n    for (var i = 0; i &lt; displayBox.length; i++) {\n    \tfor (var j = 0; j &lt; displayBox[i].length; j++) {\n    \t\tdisplayBox[i][j].display();\n    \t}\n    }\n};\n</code></pre>\n<p>The code should come as no shock. We do exactly what we did for the collisions culled array. The only difference is that we use the Camera's position (ie the top left corner of the screen) and the width and height of the screen to run the algorithm. After that, all we have to do is loop through and display each block in the culled array. The last code that you should add to your programming is the following somewhere towards the top of your code:</p>\n<pre><code class=\"javascript\">\n/* \nCredit to Liam K's Platformer Tutorial:\nhttps://www.khanacademy.org/cs/i/4978980719378432\n*/\n\n</code></pre>\n<p>There is no need to Spin-off because this is a webpage and you are most likely coding in the PJS environment. Proper attribution like above will be sufficient to avoid any plagiarism penalties.</p>\n<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(17);\">Can I have a visualization of array culling?</h5>\n\t\t<pre><code class=\"javascript\" style=\"margin-left:5px\">\n//Run this code instead of the other _World.display function\n//Make sure to switch back to the other one once your learning is complete.\n_World.display = function() {\n    \n    var displayBox = _World.cullArray(this.level, -Camera.x - _World.blockSize, -Camera.y - _World.blockSize, width + _World.blockSize * 2, height + _World.blockSize * 2);\n    \n    translate(-Camera.x + 100, -Camera.y);\n    scale(0.5);\n    translate(Camera.x, Camera.y);\n    \n    for (var i = 0; i &lt; displayBox.length; i++) {\n    \tfor (var j = 0; j &lt; displayBox[i].length; j++) {\n    \t\tdisplayBox[i][j].display();\n    \t}\n    }\n};\n</code></pre>\n</div>\n<div class=\"question\">\n\t\t<h5 onClick=\"toggleFaq(18);\">I just skipped to the end. Can I have all of the code?</h5>\n\t\t<pre><code class=\"javascript\" style=\"margin-left:5px\">\n/*\nCredit to Liam K's Platformer Tutorial:\nhttps://www.khanacademy.org/cs/i/4978980719378432\n*/\n\n\nvar scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar Camera = (function(){\n    var _Camera = {\n        x:0,\n        y:0,\n        scale:1,\n    };\n    \n    _Camera.startLink = function(){\n        pushMatrix();\n    };\n    \n    _Camera.endLink = function(){\n        popMatrix();\n    };\n    \n    _Camera.follow = function(that){\n\n\t\t//lerp the object to the center of the screen\n\t\tthis.x = lerp(this.x, width / 2 - (that.x + that.w / 2) * this.scale, 0.1);\n\t\tthis.y = lerp(this.y, height / 2 - (that.y + that.h / 2) * this.scale, 0.1);\n\n\t\t//transformations\n\t\ttranslate(~~this.x, ~~this.y);\n\t\t\n\t\ttranslate(width/2, height/2);\n\t\tscale(this.scale);\n\t\ttranslate(-width/2, -height/2);\n\n\t\n    };\n    \n    _Camera.shake = function(){\n        this.x += random(-5, 5);\n        this.y += random(-5, 5);\n    };\n    \n    _Camera.zoomTo = function(scl){\n        this.scale = lerp(this.scale, scl, 0.1);\n    };\n    \n    \n    return _Camera;\n})();\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x &lt; that.x + that.w && this.y &lt; that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv &lt; 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv &lt; 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) &lt; 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Player = (function() {\n\n\tvar _Player = function(config) {\n\t\tPhysicsBody.call(this, config);\n\t};\n\t_Player.prototype = Object.create(PhysicsBody.prototype);\n\n\t_Player.prototype.handleKeys = function() {\n\n\t\tif (keys[LEFT] || keys.a) {\n\t\t\tthis.xv -= this.acc * 3;\n\t\t} else if (keys[RIGHT] || keys.d) {\n\t\t\tthis.xv += this.acc * 3;\n\n\t\t}\n\t\tif ((keys[UP] || keys.w) && this.canJump) {\n\t\t\tthis.yv = -this.maxVelocity * 2;\n\t\t\tthis.canJump = false;\n\t\t}\n\t};\n\treturn new _Player({\n\t\tx: 100,\n\t\ty: 100,\n\t\tw: 50,\n\t\th: 50,\n\t\timagePath: \"player\",\n\t});\n\n})();\n\nvar World = (function() {\n\n\tvar _World = {\n\t\tcurrentLevel: 0,\n\n\t\tblockSize: 50,\n\n\t\t\tbitmaps: [\n\t\t\t[\n\t\t\t\t\"------------------------------------\",\n\t\t\t\t\"------------------------------------\",\n\t\t\t\t\"----------#ll#----------------------\",\n\t\t\t\t\"--P-----#-####------#-----##--------\",\n\t\t\t\t\"-----#-----------#------#####-------\",\n\t\t\t\t\"--#------#l-------------------------\",\n\t\t\t\t\"----l-#--ll------lllllllllllll--@---\",\n\t\t\t\t\"#####################################\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-P--------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t],\n        \n\t\tlevel: [],\n\t};\n\n\t_World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n\n\t_World.generateLevel = function() {\n\n\n\t\t_World.level = [];\n\n\t\tfor (var i = 0; i &lt; _World.bitmaps[_World.currentLevel].length; i++) {\n\n\t\t\tvar columnArray = [];\n\t\t\t\n\t\t\tfor (var j = 0; j &lt; _World.bitmaps[_World.currentLevel][i].length; j++) {\n\n\t\t\t\tvar currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n\n\n                if (currentType.onSpawn) {\n\t\t\t\t\tcurrentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcolumnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n\n\t\t\t}\n\n\t\t\t_World.level.push(columnArray);\n\t\t}\n\t};\n\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i &lt; endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j &lt; endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n\n\t_World.display = function() {\n\t    \n\t    var displayBox = _World.cullArray(this.level, -Camera.x - _World.blockSize, -Camera.y - _World.blockSize, width + _World.blockSize * 2, height + _World.blockSize * 2);\n\t    \n\t\tfor (var i = 0; i &lt; displayBox.length; i++) {\n\t\t\tfor (var j = 0; j &lt; displayBox[i].length; j++) {\n\t\t\t\tdisplayBox[i][j].display();\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_World.sortCollPriority = function(a,b){\n\t    return(b.collPriority - a.collPriority);\t\n\t};\n\n\treturn _World;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\t\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad &lt; Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t\tWorld.generateLevel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\t\t    \n\t\t    Camera.startLink();\n\t\t    Camera.follow(Player);\n\t\t    \n\t\t\tbackground(255);\n\t\t\tWorld.display();\n\n\t\t\tPlayer.handleKeys();\n\n\t\t\tvar collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n\n\t\t\tPlayer.updateX();\n\t\t\t//Loop through the culled array and run collisions with those blocks\n    for (var i = 0; i &lt; collBox.length; i++) {\n    \n        //Sort the blocks\n        collBox[i].sort(World.sortCollPriority);\n    \n    \tfor (var j = 0; j &lt; collBox[i].length; j++) {\n    \t    Player.collideX(collBox[i][j]);\n    \t}\n    }\n\n\t\t\tPlayer.updateY();\n\t\t\tfor (var i = 0; i &lt; collBox.length; i++) {\n\t\t\t\tfor (var j = 0; j &lt; collBox[i].length; j++) {\n\t\t\t\t\tPlayer.collideY(collBox[i][j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPlayer.display();\n\t\t\t\n\t\t\tCamera.endLink();\n\t\t\t\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\n\tclick = false;\n\n\t\n};\n\nkeyPressed = function() {\n\tkeys[key.toString()] = true;\n\tkeys[keyCode] = true;\n};\nkeyReleased = function() {\n\tdelete keys[key.toString()];\n\tdelete keys[keyCode];\n};\nmouseClicked = function() {\n\tclick = true;\n};\n</code></pre>\n\n\t</div>\n<canvas id=\"mycanvas3\"></canvas>\n\t<script type>\n\t\tvar programCode = function(processingInstance) {\n\t\t\twith(processingInstance) {\n\t\t\t\tsize(600, 600);\n\t\t\t\tframeRate(60);\n\n\nvar scene = \"load\";\nvar keys = {};\nvar click = false;\n\nvar imgs = {\n\tground: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0);\n\t\t}\n\t},\n\tair: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 0, 0);\n\t\t}\n\t},\n\tlava1: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(255, 0, 0);\n\t\t}\n\t},\n\tlava2: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 40, 0);\n\t\t}\n\t},\n\tlava3: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(235, 86, 0);\n\t\t}\n\t},\n\tplayer: {\n\t\tw: 50,\n\t\th: 50,\n\t\td: function() {\n\t\t\tbackground(0, 0, 255);\n\n\t\t\t//Draw some eyes\n\t\t\tfill(0);\n\t\t\tellipse(15, 25, 10, 20);\n\t\t\tellipse(35, 25, 10, 20);\n\t\t}\n\t},\n\tportal: {\n\t    w:50,\n\t    h:50,\n\t    d:function(){\n\t        fill(174, 86, 237);\n\t        ellipse(25,25,50,50);\n\t    }\n\t}\n};\n\nvar Camera = (function(){\n    var _Camera = {\n        x:0,\n        y:0,\n        scale:1,\n    };\n    \n    _Camera.startLink = function(){\n        pushMatrix();\n    };\n    \n    _Camera.endLink = function(){\n        popMatrix();\n    };\n    \n    _Camera.follow = function(that){\n\n\t\t//lerp the object to the center of the screen\n\t\tthis.x = lerp(this.x, width / 2 - (that.x + that.w / 2) * this.scale, 0.1);\n\t\tthis.y = lerp(this.y, height / 2 - (that.y + that.h / 2) * this.scale, 0.1);\n\n\t\t//transformations\n\t\ttranslate(~~this.x, ~~this.y);\n\t\t\n\t\ttranslate(width/2, height/2);\n\t\tscale(this.scale);\n\t\ttranslate(-width/2, -height/2);\n\n\t\n    };\n    \n    _Camera.shake = function(){\n        this.x += random(-5, 5);\n        this.y += random(-5, 5);\n    };\n    \n    _Camera.zoomTo = function(scl){\n        this.scale = lerp(this.scale, scl, 0.1);\n    };\n    \n    \n    return _Camera;\n})();\n\nvar PhysicsBody = (function() {\n\tvar _PhysicsBody = function(config) {\n\n\t\t//Initial x and y positions\n\t\tthis.x = config.x;\n\t\tthis.y = config.y;\n\n\t\t//width and height\n\t\tthis.w = config.w;\n\t\tthis.h = config.h;\n\n\t\t//x and y velocity. Default value of 0 unless otherwise specified.\n\t\tthis.xv = config.xv || 0;\n\t\tthis.yv = config.yv || 0;\n\n\t\t//Maximum velocity in pixels/frame. Default of 5.\n\t\tthis.maxVelocity = config.maxVel || 5;\n\n\t\t//Acceleration in pixels/frame/frame\n\t\tthis.acc = config.acc || 0.2;\n\n\t\t//Does gravity act on this object?\n\t\tthis.underGravity = config.underGravity || true;\n\n\t\t//Can the player jump?\n\t\tthis.canJump = false;\n\n\t\t//A string that matches one of the keys in the imgs object.\n\t\tthis.imagePath = config.imagePath;\n\n\t\t//Variables for animated images\n\t\tthis.imageIndex = 0;\n\t\tthis.animateDelay = config.animateDelay || 10;\n\n        //Can another object pass through it?\n\t\tthis.solid = config.solid;\n\n        //A function that occurs when two objects collide\n\t\tthis.onCollide = config.onCollide;\n\t\t\n\t\t//Higher numbers mean that the collision occurs first\n\t\tthis.collPriority = config.collPriority;\n\t};\n\n\t_PhysicsBody.prototype.display = function(){\n    \n        switch(typeof this.imagePath){\n            \n            //static image\n            case \"string\":\n                image(imgs[this.imagePath], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n            \n            //animated image\n            case \"object\":\n                \n                //Increment periodically to the next image\n                if(frameCount % this.animateDelay === 0){\n                    this.imageIndex ++;\n                }\n                \n                //Show the current image\n                image(imgs[this.imagePath[this.imageIndex % this.imagePath.length]], ~~this.x, ~~this.y, this.w, this.h);\n            break;\n        }\n    };\n\n\t_PhysicsBody.prototype.checkColl = function(that) {\n\t\treturn (this.x + this.w > that.x && this.y + this.h > that.y && this.x < that.x + that.w && this.y < that.y + that.h);\n\t};\n\n\t_PhysicsBody.prototype.collideX = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.xv < 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x + that.w;\n\t\t\t\t\n\t\t\t} else if (this.xv > 0 && that.solid) {\n\t\t\t    this.xv = 0;\n\t\t\t\tthis.x = that.x - this.w;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.collideY = function(that) {\n\t\tif (this.checkColl(that)) {\n\n\t\t\tthat.onCollide(this);\n\n\t\t\tif (this.yv < 0 && that.solid) {\n\t\t\t\tthis.y = that.y + that.h;\n\t\t\t\tthis.yv = -this.yv * 0.5;\n\t\t\t} else if (this.yv > 0 && that.solid) {\n\t\t\t\tthis.y = that.y - this.h;\n\t\t\t\tthis.canJump = true;\n\t\t\t\tthis.yv = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t_PhysicsBody.prototype.updateX = function() {\n\n\t\t//Apply Friction\n\t\tif (this.xv !== 0) {\n\n\t\t\t//Slow down the velocity\n\t\t\tthis.xv -= Math.sign(this.xv) * this.acc;\n\t\t\tif (abs(this.xv) < 0.0001) {\n\t\t\t\tthis.xv = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Constrain the velocity so we don't infinitely accelerate\n\t\tthis.xv = constrain(this.xv, -this.maxVelocity, this.maxVelocity);\n\n\t\t//Increment position based on velocity\n\t\tthis.x += this.xv;\n\t};\n\n\t_PhysicsBody.prototype.updateY = function() {\n\t\t//Add a gravitational force\n\t\tif (this.underGravity) {\n\t\t\tthis.yv += this.acc * 2;\n\t\t}\n\n\t\t//Increment position based on velocity\n\t\tthis.y += this.yv;\n\t};\n\n\treturn _PhysicsBody;\n})();\n\nvar Player = (function() {\n\n\tvar _Player = function(config) {\n\t\tPhysicsBody.call(this, config);\n\t};\n\t_Player.prototype = Object.create(PhysicsBody.prototype);\n\n\t_Player.prototype.handleKeys = function() {\n\n\t\tif (keys[LEFT] || keys.a) {\n\t\t\tthis.xv -= this.acc * 3;\n\t\t} else if (keys[RIGHT] || keys.d) {\n\t\t\tthis.xv += this.acc * 3;\n\n\t\t}\n\t\tif ((keys[UP] || keys.w) && this.canJump) {\n\t\t\tthis.yv = -this.maxVelocity * 2;\n\t\t\tthis.canJump = false;\n\t\t}\n\t};\n\treturn new _Player({\n\t\tx: 100,\n\t\ty: 100,\n\t\tw: 50,\n\t\th: 50,\n\t\timagePath: \"player\",\n\t});\n\n})();\n\nvar World = (function() {\n\n\tvar _World = {\n\t\tcurrentLevel: 0,\n\n\t\tblockSize: 50,\n\n\t\t\tbitmaps: [\n\t\t\t[\n\t\t\t\t\"------------------------------------\",\n\t\t\t\t\"------------------------------------\",\n\t\t\t\t\"----------#ll#----------------------\",\n\t\t\t\t\"--P-----#-####------#-----##--------\",\n\t\t\t\t\"-----#-----------#------#####-------\",\n\t\t\t\t\"--#------#l-------------------------\",\n\t\t\t\t\"----l-#--ll------lllllllllllll--@---\",\n\t\t\t\t\"#####################################\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"############\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#-P--------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"#----------#\",\n\t\t\t\t\"############\"\n\t\t\t],\n\t\t],\n        \n\t\tlevel: [],\n\t};\n\n\t_World.blockTypes = {\n\t\t\"#\": {\n\t\t\timagePath: \"ground\",\n\t\t\tsolid: true,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"-\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"l\": {\n\t\t\timagePath: [\"lava1\", \"lava2\", \"lava3\"],\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\tprintln(\"death\");\n\t\t\t},\n\t\t\tcollPriority:0,\n\t\t},\n\t\t\"P\": {\n\t\t\timagePath: \"air\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {},\n\t\t\tonSpawn:function(x, y){\n\t\t\t    Player.x = x;\n\t\t\t    Player.y = y;\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t\t\"@\": {\n\t\t\timagePath: \"portal\",\n\t\t\tsolid: false,\n\t\t\tonCollide: function() {\n\t\t\t\t_World.currentLevel ++;\n\t\t\t\t_World.generateLevel();\n\t\t\t},\n\t\t\tcollPriority:1,\n\t\t},\n\t};\n\n\t_World.generateLevel = function() {\n\n\n\t\t_World.level = [];\n\n\t\tfor (var i = 0; i < _World.bitmaps[_World.currentLevel].length; i++) {\n\n\t\t\tvar columnArray = [];\n\t\t\t\n\t\t\tfor (var j = 0; j < _World.bitmaps[_World.currentLevel][i].length; j++) {\n\n\t\t\t\tvar currentType = _World.blockTypes[_World.bitmaps[_World.currentLevel][i][j]];\n\n\n                if (currentType.onSpawn) {\n\t\t\t\t\tcurrentType.onSpawn(j * _World.blockSize, i * _World.blockSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcolumnArray.push(new PhysicsBody({\n\t\t\t\t\tx: j * _World.blockSize,\n\t\t\t\t\ty: i * _World.blockSize,\n\t\t\t\t\tw: _World.blockSize,\n\t\t\t\t\th: _World.blockSize,\n\t\t\t\t\tsolid: currentType.solid,\n\t\t\t\t\timagePath: currentType.imagePath,\n\t\t\t\t\tunderGravity: false,\n\t\t\t\t\tonCollide: currentType.onCollide,\n\t\t\t\t\tcollPriority:currentType.collPriority,\n\t\t\t\t}));\n\n\t\t\t}\n\n\t\t\t_World.level.push(columnArray);\n\t\t}\n\t};\n\n\t_World.cullArray = function(array, x, y, w, h) {\n\n\t\t//Find the top left x and y index of the array subset\n\t\tvar startX = max(~~(x / _World.blockSize), 0);\n\t\tvar startY = max(~~(y / _World.blockSize), 0);\n\n\t\t//Convert the width/height in pixels into indices in width\n\t\tvar indexWidth = ceil((w / this.blockSize));\n\t\tvar indexHeight = ceil((h / this.blockSize));\n\n\t\t//bottom right corner index values\n\t\tvar endX = min(startX + indexWidth, array[0].length);\n\t\tvar endY = min(startY + indexHeight, array.length);\n\n\t\t//Create a new array\n\t\tvar newArray = [];\n\n\t\t//Start looping\n\t\tfor (var i = startY; i < endY; i++) {\n\n\t\t\t//Create a temporary row array\n\t\t\tvar column = [];\n\n\t\t\t//fill the row array with the blocks from the old array\n\t\t\tfor (var j = startX; j < endX; j++) {\n\t\t\t\tcolumn.push(array[i][j]);\n\t\t\t}\n\n\t\t\t//add the row to the new array\n\t\t\tnewArray.push(column);\n\t\t}\n\n\t\treturn (newArray);\n\n\t};\n\n\t_World.display = function() {\n\t    \n\t    var displayBox = _World.cullArray(this.level, -Camera.x - _World.blockSize, -Camera.y - _World.blockSize, width + _World.blockSize * 2, height + _World.blockSize * 2);\n\t    \n\t\tfor (var i = 0; i < displayBox.length; i++) {\n\t\t\tfor (var j = 0; j < displayBox[i].length; j++) {\n\t\t\t\tdisplayBox[i][j].display();\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_World.sortCollPriority = function(a,b){\n\t    return(b.collPriority - a.collPriority);\t\n\t};\n\n\treturn _World;\n})();\n\nvar Scenes = (function() {\n\n\tvar curLoad = 0;\n\t\n\t// KWC @mkaelin368\n\tObject.constructor.prototype.new = (function() {\n\t\tvar obj = Object.create(this.prototype);\n\t\tthis.apply(obj, arguments);\n\t\treturn obj;\n\t});\n\n\treturn ({\n\t\tload: function() {\n\t\t\t//Modified from @OOPS Studios\n\t\t\tif (curLoad < Object.keys(imgs).length) {\n\n\t\t\t\t//Reset Defaults\n\t\t\t\tbackground(255, 0);\n\t\t\t\tnoStroke();\n\n\t\t\t\t//Cache the image object\n\t\t\t\tvar img = imgs[Object.keys(imgs)[curLoad]];\n\n\t\t\t\t//Draw the image\n\t\t\t\timg.d();\n\n\t\t\t\t//Take a snapshot and replace the image object with the actual image\n\t\t\t\timgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);\n\n\t\t\t\t//Increment to next image\n\t\t\t\tcurLoad++;\n\n\t\t\t\t//Switch to the game when done loading\n\t\t\t\tif (curLoad === Object.keys(imgs).length) {\n\t\t\t\t\tscene = 'play';\n\t\t\t\t\tWorld.generateLevel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add your custom loading screen here if you want\n\t\t\tbackground(0);\n\t\t},\n\t\tplay: function() {\n\t\t    \n\t\t    Camera.startLink();\n\t\t    Camera.follow(Player);\n\t\t    \n\t\t\tbackground(255);\n\t\t\tWorld.display();\n\n\t\t\tPlayer.handleKeys();\n\n\t\t\tvar collBox = World.cullArray(World.level, Player.x - Player.w, Player.y - Player.h, Player.w * 4, Player.h * 4);\n\n\t\t\tPlayer.updateX();\n\t\t\t//Loop through the culled array and run collisions with those blocks\n    for (var i = 0; i < collBox.length; i++) {\n    \n        //Sort the blocks\n        collBox[i].sort(World.sortCollPriority);\n    \n    \tfor (var j = 0; j < collBox[i].length; j++) {\n    \t    Player.collideX(collBox[i][j]);\n    \t}\n    }\n\n\t\t\tPlayer.updateY();\n\t\t\tfor (var i = 0; i < collBox.length; i++) {\n\t\t\t\tfor (var j = 0; j < collBox[i].length; j++) {\n\t\t\t\t\tPlayer.collideY(collBox[i][j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPlayer.display();\n\t\t\t\n\t\t\tCamera.endLink();\n\t\t\t\n\t\t},\n\t});\n\n})();\n\ndraw = function() {\n\tScenes[scene]();\n\n\tclick = false;\n\n\t\n};\n\nkeyPressed = function() {\n\tkeys[key.toString()] = true;\n\tkeys[keyCode] = true;\n};\nkeyReleased = function() {\n\tdelete keys[key.toString()];\n\tdelete keys[keyCode];\n};\nmouseClicked = function() {\n\tclick = true;\n};\n\n\t\t\t}\n\t\t};\n\n\t\t// Get the canvas that ProcessingJS will use\n\t\tvar canvas = document.getElementById(\"mycanvas3\");\n\t\t// Pass the function to ProcessingJS constructor\n\t\tvar processingInstance = new Processing(canvas, programCode);\n\t</script>\n\t\n\t<h3 class=\"parallax\">Closing Remarks</h3>\n\t<p>Now that you have a fully functional platformer base, it is your turn to go and create something awesome. Here are some things that I would like to see in your programs, and some tips on how to accomplish them:</p>\n\t<h4>Better Graphics</h4>\n\t<p>With my last platformer engine, I would occasionally see games hit the hotlist where people would use the graphics provided in this program. To be clear, the graphics on this program are <i>filler graphics</i> and are not intended to be actually used. Please create your own graphics. This program comes with the capabilities for image loading and animated graphics, so please take advantage of those features. Keep these tips in mind when creating your graphics:\n\t</p>\n\t<ul>\n\t    <li>One of my pet peeves is when people try to barf colors all over their graphics. Please pick two or three primary colors and mostly just use a spectrum between those colors. Instead of using the entire rainbow, pick a nice blue and green and then limit yourself to colors that go well with those. As a general rule of thumb, colors that have a 255 or a 0 as an rgb value are too saturated. Try picking a softer color so you don't make Liam's eyes bleed.</li>\n\t    <li>Additionally, try to keep your graphical style consistent. Games look super weird when some of the graphics are pixel art, others have pixel art but the pixels are a different size, and then a random flat art style is thrown in for no reason. Try to keep your overall look cohesive.</li>\n\t    <li>A solid colored rectangle is NOT a graphic. Whenever you make a graphic, if it was accomplished in 5 minutes, you're likely doing something wrong. Instead, take some time to add a texture. <code>.mask</code> is your friend. Adding minute details to each graphic adds a ton of character to your game.</li>\n\t    <li>PLEASE USE A BACKGROUND GRAPHIC. I have seen far too many games where the programmer spent hours designing a really cool animated player, only to use a solid gray color for the background. Not only does so much empty space look weird on the canvas, it can make the overall vibe of your game worse. Your background does not have to be super complicated. A simple parallax sky background, maybe with some noisy mountains or trees or something can make all the difference.</li>\n\t    <li>Make sure your colors fit their usage. It is generally a bad idea to have a super bright background because it can make things like the blocks, player, and enemies hard to see. Make sure the main elements of gameplay are clearly distinguishable. I have seen far too many games with beautiful graphics, but the coder used black bullets on a dark background. Make sure your colors stand out so it is not impossible to tell where the bullets are. Anything important should be clearly distinguishable</li>\n\t</ul>\n\t<h4>More functionality</h4>\n\t<p>This platformer engine was not designed to be the end-all be-all tutorial. The idea behind it was to give programmers a starting point to which they could add their own features. You'll notice that intentionally left some standard features out of this program which I expect you to add to your final product.</p>\n\t<ul>\n\t    <li>This program intentionally leaves out any scenes other than a game and a loading screen. Please take time to develop a menu, shop, and any other applicable scenes. A solid background with arial font is not enough. A menu is usually the first thing people see of your program, and I occasionally see great games that are let down by an underwhelming start. Hopefully this tutorial taught you a thing or two about scene management, so take advantage of those built in capabilities.</li>\n\t    <li>Also missing is a ton of standard block types, like trampolines, water, ladders, spikes, moving blocks, and checkpoints. Once again, this program was designed to be a starting point. If you use this tutorial, I implore you to please keep adding new features on top of the ones you created while learning how to make a platformer. The code is already set up to easily add any new block types of your choice.</li>\n\t    <li>You saw how I implemented array culling for Player collisions and how the Player inherited from the PhysicsBody class. You can do something incredibly similar to implement enemies. Perhaps try adding different enemy types, or bullets, or anything like that.</li>\n\t    <li>All of these bullet points go to illustrate one point. Keep improving your games and programs. The difference between a good programmer and a great programmer is attention to detail. A great programmer keeps adding little details, even if they don't think they will make a large difference. For example, this program could've easily been written in half the code, but I added a ton of functionality to promote learning and to show you all of the details and thinking that goes into one of my games. While it would've been far easier to not do an array culling algorithm, or to avoid object inheritance, or any other difficult concept we covered in this tutorial, the point of coding on KA is to improve your coding skills. Every time you sit down to code, code with the mindset of learning something new.</li>\n\t</ul>\n\t<p>None of these are exhaustive lists of what you could add. If you have any unique ideas, I encourage you to add them to your program. Congratulations for making it through this tutorial. As always, if you have any questions, don't hesitate to reach out.</p>\n\n\t<footer class='parallax'>©Liam K. 2024</footer>\n\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js\"></script>\n\t<script>\n\t\thljs.initHighlightingOnLoad();\n\t</script>\n\t<script type>\n\t\tfunction toggleFaq(i) {\n\t\t\tvar faq = document.getElementsByClassName(\"question\")[i];\n\t\t\tfaq.children[0].classList.toggle(\"open\");\n\t\t\tfaq.children[1].classList.toggle(\"open\");\n\n\t\t}\n\t</script>\n\t<script>\n\t    document.addEventListener('keydown', function(e){\n            if(e.code === 'Escape'){\n                document.body.innerHTML = \"<img src='https://upload.wikimedia.org/wikipedia/commons/e/ee/Chad_Codes.jpg', height=600px, width=600px>\";\n            }\n\t    });\n\t</script>\n\t<!-- The Thumbnail Script 2.1.0 12/18/2023 by Bluebird@kaid_157624541333313939750668 -->\n<script src=\"https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js\"></script>\n<script type>\n    var r = 600; \n    var s = document.documentElement.clientWidth;\n    window.parent.html2canvas = e => {\n        try {\n            html2canvas(document.body, {\n                width:   s,\n                height:  s,\n                useCORS: true,\n                onclone: e => e.getAnimations().forEach(a=>{\n                    try{\n                        a.finish()\n                    }catch{}\n                })\n            }).then(e => {\n                var c = document.createElement(\"canvas\");\n                c.width  = r;\n                c.height = r;\n                c.getContext('2d').drawImage(e, 0, 0, e.width, e.height, 0, 0, r, r);\n                window.top.postMessage(c.toDataURL(), \"*\");\n            }).catch(e => { \n                alert(\"Thumbnail Script Error: \" + e);  \n            });\n        } catch {\n            window.top.postMessage(document.createElement(\"canvas\").toDataURL(), \"*\");\n        }\n    }; \n</script>\n\t\n</body>\n\n</html>",
    "title": "Platformer Tutorial 2.0",
    "votes": 58,
    "created": "a day ago",
    "updated": "13 hours ago",
    "type": "HTML",
    "author": {
        "name": "Liam K.",
        "id": "kaid_160653079463992085090428",
        "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
    },
    "dimensions": {
        "width": 600,
        "height": 600
    },
    "forks": [],
    "posts": {
        "tips": [
            {
                "replyCount": 0,
                "votes": 14,
                "date": "a day ago",
                "author": {
                    "name": "Liam K.",
                    "id": "kaid_160653079463992085090428",
                    "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                },
                "text": "<b>Subscribe to me here</b><br><br>https://www.khanacademy.org/cs/i/6652809926492160",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 2,
                "votes": 9,
                "date": "21 hours ago",
                "author": {
                    "name": "Mushy Avocado",
                    "id": "kaid_889538221957342292210697",
                    "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                },
                "text": "YES finally someone who uses a 2D array to efficiently iterate over the blocks. <br><br>Cool tutorial, you've improved it a lot since your last one.<br><br>As for LemonTurtle's suggestion, the solution would be to assign a \"priority\" to each block. When the player checks for collisions, simply iterate over each block the player might be able to collide with, selecting the one that the player is touching and has the highest priority.<br><br>Edit: You also call it a PhysicsBody! lol what a coincidence. I use the same vocab. I even like calling what controls everything a \"world\"",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Hey that's actually a really smart idea. I will look into that and similar methods to see if I can implement that on this program. <br><br>I think we're basically the same person at this point lol. I'm ~95% sure we have the same hometowns too."
                    },
                    {
                        "date": "17 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "Oh you're going to OSU! Oh cool! Yep, I used to live in Salem. It's not my hometown though, and I don't live there anymore. I live in [REDACTED]<br><br>I actually went to Chemeketa while in high school to study architectural drafting :)"
                    }
                ]
            },
            {
                "replyCount": 6,
                "votes": 8,
                "date": "a day ago",
                "author": {
                    "name": "LemonTurtle",
                    "id": "kaid_26727758302107548837304",
                    "avatar": "/images/avatars/svg/primosaur-ultimate.svg"
                },
                "text": "If I had any complaint about this great program, it would be this:<br><br>Imagine three blocks: a block, then lava, then another block.<br>If you stand on both lava and block on the left side you won't die, but if you stand between lava and block on the right side, the collisions say you die.<br><br>This was a problem with the earlier version of your engine.<br><br>All in all, still a great engine that has helped many beginner programmers start understanding the basics of JS code on KA.",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Yeah definitely a bug that I noticed. Mushy proposed a good solution, so I will be looking into that over the next week or so and determining the best path forward.<br><br>Thank you for all your feedback!"
                    },
                    {
                        "date": "18 hours ago",
                        "author": {
                            "name": "Ibraheem Ahmed (IA)",
                            "id": "kaid_42165633374795610935956",
                            "avatar": "/images/avatars/svg/spunky-sam.svg"
                        },
                        "text": "Yes, \"left collisions\" (idk who coined this term but it's what I use) can be fixed! I just sort the array of blocks by type upon the level loading; this fixes the issue."
                    },
                    {
                        "date": "17 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "That doesn't work in Liam's case. The blocks are stored in a 2D array based on their position, so you can't sort them. The bonus of using a 2D array is that it essentially lets you have infinite blocks and the game won't slow down"
                    },
                    {
                        "date": "16 hours ago",
                        "author": {
                            "name": "Ibraheem Ahmed (IA)",
                            "id": "kaid_42165633374795610935956",
                            "avatar": "/images/avatars/svg/spunky-sam.svg"
                        },
                        "text": "Oh. Hmmmmm... fixing this problem without creating a 1D array of blocks is an interesting challenge. I'll think on it and come back to this later.<br><br><b>edit</b>: nvm you proposed a nice solution, using a <code>.priority</code> property for the individual blocks would probably work. I don't see any better way to do it.<br><br><b>edit2</b>: @below already saw it :)"
                    },
                    {
                        "date": "16 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "See my solution in the T&T. If you iterate over the nearby blocks you can select the one with the highest collision priority that the player happens to be touching"
                    },
                    {
                        "date": "14 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "I think the answer is even simpler than your method. You can simply use a sort function for each row of the 2D array to fix the problem. I successfully implemented it in a new program, and I will try to add it to this program soon<br><br>Edit: looks like this problem has been resolved and I have posted a full solution to this tutorial"
                    }
                ]
            },
            {
                "replyCount": 2,
                "votes": 7,
                "date": "18 hours ago",
                "author": {
                    "name": "Bearkirb314🐻‍❄️",
                    "id": "kaid_375460112550893828689953",
                    "avatar": "/images/avatars/svg/cs-hopper-cool.svg"
                },
                "text": "I like the self portrait on the thumbnail LiamK!",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "13 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "I can't believe they turned my face into a meme. You have no idea how annoying it is to have dozens of people ask for your signature everywhere you go."
                    },
                    {
                        "date": "11 hours ago",
                        "author": {
                            "name": "kitty mascot",
                            "id": "kaid_1066778980955332043559618",
                            "avatar": "/images/avatars/svg/sneak-peak-green.svg"
                        },
                        "text": "oh my gosh XD"
                    }
                ]
            },
            {
                "replyCount": 2,
                "votes": 7,
                "date": "18 hours ago",
                "author": {
                    "name": "Ibraheem Ahmed (IA)",
                    "id": "kaid_42165633374795610935956",
                    "avatar": "/images/avatars/svg/spunky-sam.svg"
                },
                "text": "Reading through it currently, but I found a big error I wanted to point out asap. The following example code is actually incorrect.<pre><code>var Scenes = (function(){<br><br>})();<br><br>//Is the same as <br>var Scenes = function(){<br><br>};<br>Scenes();</code></pre>The second block of code in the above example (after the comment) does not behave like the IIFE; it's actually much different. Instead of <code>Scenes</code> being assigned the result of a function, it is an actual function. To fix this, change the code to something like the below:<pre><code>var Scenes = (function(){<br><br>})();<br><br>//Is the same as <br>var callback = function(){<br><br>};<br>var Scenes = callback();</code></pre>Really like how much more object oriented this tutorial is, as opposed to the previous. Hopefully it will make it more difficult for people to just copy-paste all of your code and create their \"own\" platformers ;-;<br><br>Great tutorial :D",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "14 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Hey thank you for pointing this out to me IA! I will implement your code shortly."
                    },
                    {
                        "date": "11 hours ago",
                        "author": {
                            "name": "kitty mascot",
                            "id": "kaid_1066778980955332043559618",
                            "avatar": "/images/avatars/svg/sneak-peak-green.svg"
                        },
                        "text": "@ IA i read your bio... and i can now say i am thoroughly terrified"
                    }
                ]
            },
            {
                "replyCount": 0,
                "votes": 5,
                "date": "20 hours ago",
                "author": {
                    "name": "AGnawKneeMouse Coder",
                    "id": "kaid_9033829293805621369025816",
                    "avatar": "/images/avatars/svg/leaf-red.svg"
                },
                "text": "That thumbnail goes hard",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 1,
                "votes": 3,
                "date": "21 hours ago",
                "author": {
                    "name": "YokieBob",
                    "id": "kaid_681887786554114354822051",
                    "avatar": "/images/avatars/svg/marcimus-red.svg"
                },
                "text": "Now I can code like Chad.<br><br>Notes and questions<br>For <code>num/abs(num)</code> you can just do <code>Math.sign(num)</code>.<br><br>Why do you use <code>this.acc * 2</code>? Is there some physics thing that wants you to multiply the constant?<br><br>You use ~~ but then you use the floor later on in the cull array algorithm. You aren't hitting negative numbers so why the change.<br><br>You cull the array TWICE! Btw is it really that fast to check all of the blocks each frame and add them to the array? If so, neato.",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "1) Thanks for the tip about Math.sign. I didn't know that existed so I will definitely be implementing that.<br><br>2) There isn't really a hard and fast physics rule for <code>this.acc * 2.</code> Basically the frictional force is always opposing the direction of motion in the x direction with an acceleration of 0.1. Because the player's driving acceleration is 0.3, the gravitational acceleration is 0.2 so the player accelerates at 0.2 in both the x and y directions.<br><br>3) The array cull algorithm is a holdover from another program, so I didn't code it specifically for this tutorial like most of the other code. That is just an integration issue. I would recommend using ~~ in most cases. <br><br>4) In most of my other programs, I don't actually use an array cull algorithm, but simply loop through the levels array without the use of an intermediary array. While the second method is definitely faster, the array cull algorithm ends up looking cleaner, is more reusable, and is easier to  implement. Both ways allow you to ignore any unnecessary blocks. I don't think that the speed difference is significant enough to have any adverse effect unless you are attempting something crazy with other parts of your code, which is beyond the scope of this tutorial"
                    }
                ]
            },
            {
                "replyCount": 1,
                "votes": 2,
                "date": "18 hours ago",
                "author": {
                    "name": "theBTG15",
                    "id": "kaid_1184047636356324637542824",
                    "avatar": "/images/avatars/svg/starky-ultimate.svg"
                },
                "text": "This is exactly what I've been looking for lately! (I'm working on a platformer) I'm glad that you decided to make a version 2.0 of the original. Vote++! BTW I love the clickbait thumbnail. Keep it up!",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "14 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "No problem. I hope to see you create something great!"
                    }
                ]
            },
            {
                "replyCount": 10,
                "votes": 2,
                "date": "21 hours ago",
                "author": {
                    "name": "Duke",
                    "id": "kaid_351465532815782433620675",
                    "avatar": "/images/avatars/svg/starky-ultimate.svg"
                },
                "text": "I typed out a big comment of feedback and then my computer decided it wanted to power down with 98% left -_-<br><br>Welp, this is a huge step up from your last one, excellently explained. Super glad you used IIFEs, would a better way to do the prototypes be<br><pre><code>Name.prototype = {<br>    display: function() {},<br>};</code></pre><br>ig it comes down to opinion.<br>Overall just the right balance of complexity!<br>I'm glad you pointed out that rects aren't graphics.",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "I wouldn't use that method of assigning prototypes because it breaks object inheritance.<br><br>This won't work<br><pre><code>function Foo() {<br><br>}<br><br>Foo.prototype.print = function() {<br>    println(true);<br>};<br><br>function Name() {<br>    Foo.call(this);<br>}<br><br>Name.prototype = Object.create(Foo.prototype);<br>Name.prototype = {<br>    // Code goes here<br>};<br><br>var name = new Name();<br>name.print(); // Error because Name.prototype was overridden to be an object instead.</code></pre>"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Duke",
                            "id": "kaid_351465532815782433620675",
                            "avatar": "/images/avatars/svg/starky-ultimate.svg"
                        },
                        "text": "oh yessir I forgot about that. I haven't used inheritance in a while(I need to get back into that habit)<br>Thanks for the reminder =D"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "bravo bravo",
                            "id": "kaid_3550040499775075061747637",
                            "avatar": "/images/avatars/svg/leaf-grey.svg"
                        },
                        "text": "This would probably work:<br><br><pre><code>Name.prototype = Object.assign(<br>  {},<br>  Object.create(Foo.prototype),<br>  {<br>     // additional methods<br>  }<br>);</code></pre><br><br>es5 sucks and classes are so much cleaner"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "Honestly I never used inheritance much either until I got into ES6 javascript, where inheritance is much cleaner and less unwieldy.<br><br>Example:<br><pre><code>class Foo {<br>    print() {<br>        println(true);<br>    }<br>}<br><br>class Bar extends Foo {<br>    <br>}<br><br>var bar = new Bar();<br>bar.print(); // Logs true</code></pre>"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "bravo bravo",
                            "id": "kaid_3550040499775075061747637",
                            "avatar": "/images/avatars/svg/leaf-grey.svg"
                        },
                        "text": "even better typescript where you can make abstract classes and methods, even private methods, etc. (syntactically)"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Duke",
                            "id": "kaid_351465532815782433620675",
                            "avatar": "/images/avatars/svg/starky-ultimate.svg"
                        },
                        "text": "@Bravo Bravo I have heard about class's. But while on ka I try to make the best of what I have :P<br>haha having never <em>really</em> used inheritance I wouldn't know but ig your right :P<br><br>@Mush yeah ES6 looks sweet. I just haven't had much access to any other coding sight(that uses ES6)"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Mushy Avocado",
                            "id": "kaid_889538221957342292210697",
                            "avatar": "/images/avatars/svg/orange-juice-squid.svg"
                        },
                        "text": "If you use my Khan Academy exporter you can use ES6 syntax while at the same time writing normal PJS code. ES6 works in the HTML environment :)"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "bravo bravo",
                            "id": "kaid_3550040499775075061747637",
                            "avatar": "/images/avatars/svg/leaf-grey.svg"
                        },
                        "text": "Duke you should take some courses on modern js, it'll help you out in a lot of ways. try freecodecamp or codeacademy"
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Looks like Mushy pretty much summed it up. While this tutorial was designed to be run solely in the PJS environment, I would highly recommend transferring your code over to an HTML environment to rid yourself of most of the flaws of PJS."
                    },
                    {
                        "date": "20 hours ago",
                        "author": {
                            "name": "Duke",
                            "id": "kaid_351465532815782433620675",
                            "avatar": "/images/avatars/svg/starky-ultimate.svg"
                        },
                        "text": "@Mushy ooh I didn't know that! Sweet I'll definitely look at that ;P<br><br>@Bravo I'll make sure to check that out!<br><br>@Liam I'll definitely look into that =D"
                    }
                ]
            },
            {
                "replyCount": 1,
                "votes": 2,
                "date": "14 hours ago",
                "author": {
                    "name": "Timothy",
                    "id": "kaid_580436051254509721948310",
                    "avatar": "/images/avatars/svg/cs-hopper-jumping.svg"
                },
                "text": "Insane! Insane that you manage to do this as a college student! Good luck with Statics or whatever they are throwing at you right now :D",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "14 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "My schedule is actually way too easy as it currently is. My one 'engineering' class is a you breath you get an A type course. My hardest classes in terms of workload are probably Physics and Math. Considering that I already took physics in high school with a 90% overlap between my current class and my high school class, it hasn't been super difficult.<br><br>I'm thinking about joining a game jam for the Video Design club here, so I might have something else to release in a week or so."
                    }
                ]
            },
            {
                "replyCount": 0,
                "votes": 2,
                "date": "14 hours ago",
                "author": {
                    "name": "WESTY METZY",
                    "id": "kaid_7615172111979300259760122",
                    "avatar": "/images/avatars/svg/mr-pink.svg"
                },
                "text": "I love how u credit urself",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 0,
                "votes": 2,
                "date": "15 hours ago",
                "author": {
                    "name": "Falling Dragon™️",
                    "id": "kaid_922990378162047462529587",
                    "avatar": "/images/avatars/svg/leaf-blue.svg"
                },
                "text": "esc for chad",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 1,
                "votes": 1,
                "date": "15 hours ago",
                "author": {
                    "name": "LJE",
                    "id": "kaid_1034761647362147362261181",
                    "avatar": "/images/avatars/svg/duskpin-sapling.svg"
                },
                "text": "thumbnail cilckbait... -_- it gets me everytime XD<br>glad to see u still around! :)",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "14 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Thanks LJE! I am glad to see that you're still on this site too."
                    }
                ]
            },
            {
                "replyCount": 0,
                "votes": 1,
                "date": "18 hours ago",
                "author": {
                    "name": "kitty mascot",
                    "id": "kaid_1066778980955332043559618",
                    "avatar": "/images/avatars/svg/sneak-peak-green.svg"
                },
                "text": "bro... that thumb nail XD",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 0,
                "votes": 1,
                "date": "an hour ago",
                "author": {
                    "name": "LJ",
                    "id": "kaid_1144628223469068678737336",
                    "avatar": "/images/avatars/svg/leafers-sapling.svg"
                },
                "text": "Very chad indeed 👍",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 0,
                "votes": 1,
                "date": "9 hours ago",
                "author": {
                    "name": "ÐoɠIovɛɼ",
                    "id": "kaid_174620599098233073374167",
                    "avatar": "/images/avatars/svg/leaf-red.svg"
                },
                "text": "dropping a comment to save this for later :)<br>hope life's been good, amazing that you have time to do this in college!",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 2,
                "votes": 1,
                "date": "21 hours ago",
                "author": {
                    "name": "TH3 ROUG3 L3G3ND™",
                    "id": "kaid_2809101008758048501324524",
                    "avatar": "/images/avatars/svg/boggle-blue.svg"
                },
                "text": "4,600 lines of code(I don't have the patience)",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "You only end up coding ~450 lines of code. This tutorial is mostly just super bulky because I had to recopy/paste lots of the same code every time I wanted to add new code. <br><br>This tutorial is super doable even for beginners, so I'd recommend that you take a stab at it."
                    },
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "TH3 ROUG3 L3G3ND™",
                            "id": "kaid_2809101008758048501324524",
                            "avatar": "/images/avatars/svg/boggle-blue.svg"
                        },
                        "text": "no I was talking about this platformer tutorial program you did a great job coding 4,600 lines of code!"
                    }
                ]
            },
            {
                "replyCount": 1,
                "votes": 1,
                "date": "21 hours ago",
                "author": {
                    "name": "HB_the_Pencil (semi-retired)",
                    "id": "kaid_412656070256786668848958",
                    "avatar": "/images/avatars/svg/mr-pants-green.svg"
                },
                "text": "Holy moly, what an in-depth tutorial! Thanks!",
                "locked": false,
                "pinned": false,
                "replies": [
                    {
                        "date": "21 hours ago",
                        "author": {
                            "name": "Liam K.",
                            "id": "kaid_160653079463992085090428",
                            "avatar": "/images/avatars/svg/duskpin-ultimate.svg"
                        },
                        "text": "Thank you HB! Hopefully this program will be helpful to you"
                    }
                ]
            },
            {
                "replyCount": 0,
                "votes": 1,
                "date": "16 hours ago",
                "author": {
                    "name": "The Multiverse Hero",
                    "id": "kaid_523988888981336150053758",
                    "avatar": "/images/avatars/svg/starky-sapling.svg"
                },
                "text": "Now this is some Gigachadian coding! Thanks so much for this Mr. K.",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 0,
                "votes": 1,
                "date": "17 hours ago",
                "author": {
                    "name": "ASBackup",
                    "id": "kaid_714780036830891967670231",
                    "avatar": "/images/avatars/svg/aqualine-tree.svg"
                },
                "text": "eyy liam :)<br>looks great!<br>amazing thumbnail lol",
                "locked": false,
                "pinned": false,
                "replies": []
            },
            {
                "replyCount": 0,
                "votes": 0,
                "date": "19 hours ago",
                "author": {
                    "name": "JJP",
                    "id": "kaid_874785892689340729331212",
                    "avatar": "/images/avatars/svg/aqualine-seedling.svg"
                },
                "text": "All thumbnails use clickbait. The definition of clickbait is basically any type of thumbnail or title that is supposed to lure people into clicking your program. Hopefully this modified your understanding of clickbait!",
                "locked": false,
                "pinned": false,
                "replies": []
            }
        ],
        "questions": []
    }
}